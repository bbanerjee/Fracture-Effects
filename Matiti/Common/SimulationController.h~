
#ifndef MATITI_SIMULATIONCONTROLLER_H
#define MATITI_SIMULATIONCONTROLLER_H

#include <Core/Parallel/SerialComponent.h>
#include <CCA/Ports/DataWarehouseP.h>
#include <Core/Grid/GridP.h>
#include <Core/Grid/LevelP.h>
#include <Core/Grid/SimulationStateP.h>
#include <Core/Grid/SimulationState.h>
#include <CCA/Ports/SchedulerP.h>
#include <CCA/Ports/Scheduler.h>
#include <Core/ProblemSpec/ProblemSpecP.h>
#include <Core/ProblemSpec/ProblemSpec.h>


namespace Matiti {

class SimulationInterface;
class Output;
class LoadBalancer;
struct SimulationTime;
class Regridder;
class DataArchive;


   //! The main component that controls the execution of the 
   //! entire simulation. 
   class SimulationController : public SerialComponent {
   public:
      SimulationController(Uintah::ProblemSpecP pspec);
      virtual ~SimulationController();

      //! Notifies (before calling run) the SimulationController
      //! that this is simulation is a restart.
      void doRestart(std::string restartFromDir, int timestep,
		     bool fromScratch, bool removeOldDir);

      //! Execute the simulation
      virtual void run() = 0;

   protected:

      double getWallTime     ( void );
      void   calcWallTime    ( void );

      double getStartTime    ( void );
      void   calcStartTime   ( void );
      void   setStartSimTime ( double t );

      void preGridSetup();
      GridP gridSetup();
      void postGridSetup( GridP& grid, double& t);

      //! adjust delt based on timeinfo and other parameters
      //    'first' is whether this is the first time adjustDelT is called.
      void adjustDelT(double& delt, double prev_delt, bool first, double t);
      void initSimulationStatsVars ( void );
      void printSimulationStats    ( int timestep, double delt, double time );

      ProblemSpecP         d_ups;
      ProblemSpecP         d_grid_ps;         // Problem Spec for the Grid
      SimulationStateP     d_sharedState;
      SchedulerP           d_scheduler;
      LoadBalancer*        d_lb;
      Output*              d_output;
      SimulationTime*      d_timeinfo;
      SimulationInterface* d_sim;
      Regridder*           d_regridder;
      DataArchive*         d_archive;

      bool d_doMultiTaskgraphing;

      /* for restarting */
      bool d_restarting;
      std::string d_fromDir;
      int d_restartTimestep;
      int d_restartIndex;

      int d_lastRecompileTimestep;

      // If d_restartFromScratch is true then don't copy or move any of
      // the old timesteps or dat files from the old directory.  Run as
      // as if it were running from scratch but with initial conditions
      // given by the restart checkpoint.
      bool d_restartFromScratch;

   private:

      int    d_n;
      double d_wallTime;              // current wall time
      double d_startTime;             // starting wall time
      double d_startSimTime;          // starting sim time
      double d_prevWallTime;
     
      // this is for calculating an exponential moving average
      double d_movingAverage;
   };

} // End namespace Matiti

#endif
