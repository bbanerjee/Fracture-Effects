<!DOCTYPE HTML>
<html class="no-js" lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Geometric closest point return algorithm</title>
  <link rel="stylesheet" href="https://bbanerjee.github.io/ParSim/assets/css/screen.css">
  <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic%7cVolkhov:400,700' rel='stylesheet' type='text/css'>
  <script src="https://bbanerjee.github.io/ParSim/assets/js/modernizr.min.js"></script>
</head>


<body class="wrap">

  <script type="text/javascript"
    src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLorMML">
  </script>

  <header>
  <div class="grid">
    <div class="unit one-third center-on-mobiles">
      <h1>
        <a href="/">
          <span class="sr-only">ParSim</span>
          <img src="https://bbanerjee.github.io/ParSim/assets/img/ParresiaLogoDec2016.png" 
               width="249" height="115" alt="ParSim">
        </a>
      </h1>
    </div>
    <nav class="main-nav unit two-thirds hide-on-mobiles">
      <ul>
  <li class="">
    <a href="https://bbanerjee.github.io/ParSim">Home</a>
  </li>
  <li class="current">
    <a href="https://bbanerjee.github.io/ParSim/docs/home">Vaango Docs</a>
  </li>
  <li>
    <a href="https://github.com/bbanerjee/ParSim">GitHub Source</a>
  </li>
</ul>

    </nav>
  </div>
</header>



    <section class="docs">
    <div class="grid">

      <div class="unit four-fifths">
        <article>
          <h1>Geometric closest point return algorithm</h1>
          <ul class="notice--content" id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#the-arena-yield-function" id="markdown-toc-the-arena-yield-function">The Arena yield function</a></li>
  <li><a href="#the-non-hardening-return-algorithm" id="markdown-toc-the-non-hardening-return-algorithm">The non-hardening return algorithm</a></li>
  <li><a href="#the-closest-point-algorithm" id="markdown-toc-the-closest-point-algorithm">The closest point algorithm</a></li>
  <li><a href="#an-animation-of-the-closest-point-algorithm" id="markdown-toc-an-animation-of-the-closest-point-algorithm">An animation of the closest point algorithm</a></li>
  <li><a href="#remarks" id="markdown-toc-remarks">Remarks</a></li>
</ul>

<h5 id="introduction">Introduction</h5>
<p>In <a href="https://bbanerjee.github.io/ParSim/mechanics/plasticity/algorithm/closest-point-return/">Part 7</a>, we saw that
for isotropic elastic materials and perfect associated plasticity, the trial stress
and the actual stress are at the shortest distance from each other in a transformed stress
space.  We also saw that the transformed stress can be expressed as</p>
<div>
$$
  \boldsymbol{\sigma}^\star 
  = \frac{z}{\sqrt{3\kappa}}\,\mathbf{E}_z +
    \frac{r}{\sqrt{2\mu}}\,\mathbf{E}_r
$$
</div>
<p>where</p>
<div>
$$
  z = \tfrac{1}{\sqrt{3}}\,\text{tr}(\boldsymbol{\sigma}) ~,~~
  r = \lVert \boldsymbol{s} \rVert 
$$
</div>
<p>and</p>
<div>
$$
  \mathbf{E}_z = \tfrac{1}{\sqrt{3}}\,\mathbf{I} ~,~~
  \mathbf{E}_r = \frac{\boldsymbol{s}}{\lVert\boldsymbol{s}\rVert} \,.
$$
</div>
<p>We can show that the transformed stress vector remains geometrically unchanged (in the sense that
angles are unchanged) if we express it as</p>
<div class="notice">
$$
  \boldsymbol{\sigma}^\star 
  = z\,\mathbf{E}_z + \sqrt{\frac{3\kappa}{2\mu}}\,r\,\mathbf{E}_r
  =: z\,\mathbf{E}_z + r'\,\mathbf{E}_r
$$
</div>
<p>This observation can be used to perform a purely geometric stress update that can
be quite efficient for nonlinear Drucker-Prager plasticity and many other phenomenological
plasticity models.  Let us see how this concept has been applied to the <a href="https://github.com/bbanerjee/ParSim/blob/master/Vaango/src/CCA/Components/MPM/ConstitutiveModel/Arenisca3PartiallySaturated.cc">Arena plasticity
model</a>.</p>

<h5 id="the-arena-yield-function">The Arena yield function</h5>
<p>The Arena model is an extension to partially saturated soils of the Arenisca model
developed by R. M. Brannon and co-workers.  The yield function used by this model is a
nonlinear Drucker-Prager model with a compression cap.  Further details can be found in
the <a href="https://github.com/bbanerjee/ParSim/tree/master/Vaango/Manuals/TheoryGuide/ArenaSoil">Arena theory manual</a>.</p>

<p>If the volumetric and deviatoric components of the total stress are</p>
<div>
$$
    \bar{p} := -\tfrac{1}{3} \text{tr}(\boldsymbol{\sigma}) \quad \text{and} \quad \boldsymbol{s} := \boldsymbol{\sigma} + \bar{p} \mathbf{I}
$$
</div>
<p>we can define</p>
<div>
$$
  \begin{align}
    \bar{p}_\text{eff} &amp; := -\tfrac{1}{3} \text{tr}(\boldsymbol{\sigma}_\text{eff}) = \bar{p} - B \bar{p}^w \\
    \boldsymbol{s}_\text{eff} &amp; := \boldsymbol{\sigma}_\text{eff} + \bar{p}_\text{eff} \mathbf{I} = \boldsymbol{\sigma} + \bar{p} \mathbf{I} = \boldsymbol{s} \\
    J_2^\text{eff} &amp; := \tfrac{1}{2} \boldsymbol{s}_\text{eff}:\boldsymbol{s}_\text{eff}  \,.
  \end{align}
$$
</div>
<p>Then the Arena yield function is</p>
<div class="notice">
$$
     f(\boldsymbol{\sigma}, B, \bar{p}^w, \bar{X}) =
       \sqrt{J_2^\text{eff}} - F_f(\bar{p}_\text{eff}) \, F_c(\bar{p}_\text{eff}, \bar{X})
$$
</div>
<p>where</p>
<div class="notice">
$$
    F_f(\bar{p}_\text{eff})  = a_1 - a_3 \exp[- 3 a_2 \bar{p}_\text{eff}] + 3 a_4 \bar{p}_\text{eff}
$$
</div>
<p>and</p>
<div class="notice">
$$
    F_c(\bar{p}_\text{eff}, \bar{X})  =
       \begin{cases}
         1 &amp; \quad \text{for}\quad 3\bar{p}_\text{eff} \le \bar{\kappa} \\
         \sqrt{1 - \left(\cfrac{3\bar{p}_\text{eff} - \bar{\kappa}}{\bar{X}_\text{eff} - \bar{\kappa}}\right)^2} &amp;
           \quad \text{for}\quad 3\bar{p}_\text{eff} &gt; \bar{\kappa} \,.
       \end{cases}
$$
</div>
<p>Here <script type="math/tex">a_i</script> are material parameters, <script type="math/tex">\bar{X}_\text{eff}(\boldsymbol{\varepsilon}^p, B, \bar{p}^w) = \bar{X} - 3B\bar{p}^w</script> is the
shifted form of the apparent hydrostatic compressive strength (<script type="math/tex">\bar{X}/3</script>) of the partially saturated
material, and <script type="math/tex">\bar{\kappa}</script> is the branch point at which the cap function <script type="math/tex">F_c</script> starts decreasing until it
reaches the hydrostatic strength point (<script type="math/tex">\bar{X}</script>):</p>
<div class="notice">
$$
    \bar{\kappa} = 3\bar{p}_\text{eff}^\text{peak} - (3\bar{p}_\text{eff}^\text{peak} - \bar{X}_\text{eff}) R_c
$$
</div>
<p>where <script type="math/tex">\bar{p}_\text{eff}^\text{peak}</script> is the maximum hydrostatic tensile stress that the material can
support and <script type="math/tex">R_c</script> is a cap ratio.</p>

<h5 id="the-non-hardening-return-algorithm">The non-hardening return algorithm</h5>
<p>We use the closest-point return approach discussed in the previous articles in this series to
compute a return to the yield surface while keeping all internal variables fixed.
The pseudocsode of the algorithm is listed below:</p>
<div class="notice--info">
$$
  \begin{align}
    &amp;\text{Require:} &amp;&amp; \boldsymbol{\sigma}^k, \delta\boldsymbol{\varepsilon}, X^k, K^k, G^k,
                          (\bar{p}^w)^k, \boldsymbol{s}^\text{trial}, \sqrt{J_2^\text{trial}},
                          r^\text{trial}, z_\text{eff}^\text{trial}, \\
    &amp;                &amp;&amp;  a_1, a_2, a_3, a_4, I_1^\text{peak}, R_c \\
    &amp;\text{Procedure:} &amp;&amp; \text{nonHardeningReturn} \\
    &amp;   1.\quad &amp;&amp;   r'_\text{trial} \leftarrow r^\text{trial} \sqrt{\cfrac{3K^k}{2G^k}}
                \qquad \mbox{Transform the trial $r$ coordinate} \\
    &amp;   2.\quad &amp;&amp;   X_\text{eff}^k \leftarrow X^k + 3 (\bar{p}^w)^k \\
    &amp;   3.\quad &amp;&amp;   z_\text{eff}^\text{closest}, r'_\text{closest} \leftarrow
           \text{getClosestPoint}(K^k, G^k, X_\text{eff}^k, a_1, a_2, a_3, a_4,\\
    &amp;      &amp;&amp;   \qquad \qquad\qquad I_1^\text{peak}, R_c, z_\text{eff}^\text{trial}, r'_\text{trial}) \\
    &amp;   4.\quad &amp;&amp;   I_1^{\text{closest}} \leftarrow \sqrt{3} z_\text{eff}^\text{closest} - 3 (\bar{p}^w)^k,
              \sqrt{J_2^\text{closest}} \leftarrow \sqrt{\frac{G^k}{3K^k}}\,r'_\text{closest} \\
    &amp;   5.\quad &amp;&amp;  \text{If} {\sqrt{J_2^\text{trial}} &gt; 0} \\
    &amp;      6. &amp;&amp;  \qquad \boldsymbol{\sigma}^\text{fixed} = \tfrac{1}{3} I_1^{\text{closest}} \mathbf{I} +
          \frac{\sqrt{J_2^\text{closest}}}{\sqrt{J_2^\text{trial}}}\,\boldsymbol{s}^\text{trial} \\
    &amp;         &amp;&amp;  \qquad \mbox{Compute updated total stress} \\
    &amp;   7.\quad &amp;&amp;  \text{Else} \\
    &amp;      8. &amp;&amp;  \qquad \boldsymbol{\sigma}^\text{fixed} = \tfrac{1}{3} I_1^{\text{closest}} \mathbf{I} +
                  \boldsymbol{s}^\text{trial}\\
    &amp;         &amp;&amp; \qquad
                \mbox{Compute updated total stress from hydrostatic trial stress} \\
    &amp;   9.\quad &amp;&amp;  \text{EndIf} \\
    &amp;   10.\quad &amp;&amp;  \delta\boldsymbol{\sigma}_\text{fixed} \leftarrow \boldsymbol{\sigma}^\text{fixed} -
              \boldsymbol{\sigma}^k \qquad \mbox{Compute stress increment} \\
    &amp;   11.\quad &amp;&amp;  \delta\boldsymbol{\sigma}_\text{fixed}^\text{iso} \leftarrow \tfrac{1}{3}
                \text{tr}(\delta\boldsymbol{\sigma}_\text{fixed}) \mathbf{I}, 
         \quad \delta\boldsymbol{\sigma}_\text{fixed}^\text{dev} \leftarrow
          \delta\boldsymbol{\sigma}_\text{fixed} - \delta\boldsymbol{\sigma}_\text{fixed}^\text{iso} \\
    &amp;   12.\quad &amp;&amp;  \delta\boldsymbol{\varepsilon}^{p,\text{fixed}} = \delta\boldsymbol{\varepsilon} -
             \frac{1}{3K^k}\,\delta\boldsymbol{\sigma}_\text{fixed}^\text{iso} -
             \frac{1}{2G^k}\,\delta\boldsymbol{\sigma}_\text{fixed}^\text{dev} \\
    &amp;    &amp;&amp;    \quad\mbox{Compute plastic strain increment} \\
    &amp;   13.\quad &amp;&amp;  \text{Return} \qquad \boldsymbol{\sigma}^\text{fixed}, \delta\boldsymbol{\varepsilon}^{p,\text{fixed}} \\
  \end{align}
$$
</div>

<h5 id="the-closest-point-algorithm">The closest point algorithm</h5>
<p>Let us look at the actual implementation to get a feel for how the closest point can be found
geometrically.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span></span><span class="kt">bool</span>
<span class="n">YieldCond_Arena</span><span class="o">::</span><span class="n">getClosestPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">ModelState_Arena</span><span class="o">*</span> <span class="n">state</span><span class="p">,</span> <span class="c1">// The plasticity state</span>
                                 <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">px</span><span class="p">,</span>              <span class="c1">// The trial stress z, r&#39;</span>
                                 <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">py</span><span class="p">,</span>
                                 <span class="kt">double</span><span class="o">&amp;</span> <span class="n">cpx</span><span class="p">,</span>                   <span class="c1">// The closest point z, r&#39;</span>
                                 <span class="kt">double</span><span class="o">&amp;</span> <span class="n">cpy</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Point</span> <span class="n">pt</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
  <span class="n">Point</span> <span class="nf">closest</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
  <span class="n">getClosestPointGeometricBisect</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">closest</span><span class="p">);</span>
  <span class="n">cpx</span> <span class="o">=</span> <span class="n">closest</span><span class="p">.</span><span class="n">x</span><span class="p">();</span>
  <span class="n">cpy</span> <span class="o">=</span> <span class="n">closest</span><span class="p">.</span><span class="n">y</span><span class="p">();</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The bisection algorithm for the closest point can be implemented as shown below.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span></span><span class="kt">void</span>
<span class="n">YieldCond_MasonSand</span><span class="o">::</span><span class="n">getClosestPointGeometricBisect</span><span class="p">(</span><span class="k">const</span> <span class="n">ModelState_Arena</span><span class="o">*</span> <span class="n">state</span><span class="p">,</span>
                                                    <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">z_r_pt</span><span class="p">,</span>
                                                    <span class="n">Point</span><span class="o">&amp;</span> <span class="n">z_r_closest</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Get the particle specific internal variables from the model state</span>
  <span class="c1">// Store in a local struct</span>
  <span class="n">d_local</span><span class="p">.</span><span class="n">PEAKI1</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">yieldParams</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;PEAKI1&quot;</span><span class="p">);</span>
  <span class="p">................</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">limitParameters</span> <span class="o">=</span>
    <span class="n">computeModelParameters</span><span class="p">(</span><span class="n">d_local</span><span class="p">.</span><span class="n">PEAKI1</span><span class="p">,</span> <span class="n">d_local</span><span class="p">.</span><span class="n">FSLOPE</span><span class="p">,</span> <span class="n">d_local</span><span class="p">.</span><span class="n">STREN</span><span class="p">,</span> <span class="n">d_local</span><span class="p">.</span><span class="n">YSLOPE</span><span class="p">);</span>
  <span class="n">d_local</span><span class="p">.</span><span class="n">a1</span> <span class="o">=</span> <span class="n">limitParameters</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="n">d_local</span><span class="p">.</span><span class="n">a2</span> <span class="o">=</span> <span class="n">limitParameters</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">................</span>

  <span class="c1">// Get the plastic internal variables from the model state</span>
  <span class="kt">double</span> <span class="n">pbar_w</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">pbar_w</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">X_eff</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">capX</span> <span class="o">+</span> <span class="mf">3.0</span><span class="o">*</span><span class="n">pbar_w</span><span class="p">;</span>

  <span class="c1">// Compute kappa</span>
  <span class="kt">double</span> <span class="n">I1_diff</span> <span class="o">=</span> <span class="n">d_local</span><span class="p">.</span><span class="n">PEAKI1</span> <span class="o">-</span> <span class="n">X_eff</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">kappa</span> <span class="o">=</span>  <span class="n">d_local</span><span class="p">.</span><span class="n">PEAKI1</span> <span class="o">-</span> <span class="n">d_local</span><span class="p">.</span><span class="n">CR</span><span class="o">*</span><span class="n">I1_diff</span><span class="p">;</span>

  <span class="c1">// Get the bulk and shear moduli and compute sqrt(3/2 K/G)</span>
  <span class="kt">double</span> <span class="n">sqrtKG</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.5</span><span class="o">*</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">bulkModulus</span><span class="o">/</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">shearModulus</span><span class="p">);</span>

  <span class="c1">// Compute diameter of yield surface in z-r space</span>
  <span class="kt">double</span> <span class="n">sqrtJ2_diff</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">evalYieldConditionMax</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">yield_surf_dia_zrprime</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">I1_diff</span><span class="o">*</span><span class="n">one_sqrt_three</span><span class="p">,</span> <span class="n">sqrtJ2_diff</span><span class="o">*</span><span class="n">sqrt_two</span><span class="o">*</span><span class="n">sqrtKG</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">dist_to_trial_zr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">z_r_pt</span><span class="p">.</span><span class="n">x</span><span class="p">()</span><span class="o">*</span><span class="n">z_r_pt</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">+</span> <span class="n">z_r_pt</span><span class="p">.</span><span class="n">y</span><span class="p">()</span><span class="o">*</span><span class="n">z_r_pt</span><span class="p">.</span><span class="n">y</span><span class="p">());</span>
  <span class="kt">double</span> <span class="n">dist_dia_ratio</span> <span class="o">=</span> <span class="n">dist_to_trial_zr</span><span class="o">/</span><span class="n">yield_surf_dia_zrprime</span><span class="p">;</span>

  <span class="c1">// Set the number of points used to discretize the yield surface</span>
  <span class="kt">int</span> <span class="n">num_points</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">log</span><span class="p">(</span><span class="n">dist_dia_ratio</span><span class="p">)));</span>

   <span class="c1">// Set up I1 limits</span>
  <span class="kt">double</span> <span class="n">I1eff_min</span> <span class="o">=</span> <span class="n">X_eff</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">I1eff_max</span> <span class="o">=</span> <span class="n">d_local</span><span class="p">.</span><span class="n">PEAKI1</span><span class="p">;</span>

  <span class="c1">// Set up bisection</span>
  <span class="kt">double</span> <span class="n">eta_lo</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">eta_hi</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

  <span class="c1">// Set up mid point</span>
  <span class="kt">double</span> <span class="n">I1eff_mid</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">I1eff_min</span> <span class="o">+</span> <span class="n">I1eff_max</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">eta_mid</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">eta_lo</span> <span class="o">+</span> <span class="n">eta_hi</span><span class="p">);</span>

  <span class="c1">// Do bisection</span>
  <span class="kt">int</span> <span class="n">iters</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">TOLERANCE</span> <span class="o">=</span> <span class="mf">1.0e-10</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">z_r_points</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">z_r_segments</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">z_r_segment_points</span><span class="p">;</span>
  <span class="n">Point</span> <span class="n">z_r_closest_old</span><span class="p">;</span>
  <span class="n">z_r_closest_old</span><span class="p">.</span><span class="n">x</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
  <span class="n">z_r_closest_old</span><span class="p">.</span><span class="n">y</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
  <span class="n">z_r_closest_old</span><span class="p">.</span><span class="n">z</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">eta_hi</span> <span class="o">-</span> <span class="n">eta_lo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">TOLERANCE</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// Get the yield surface points</span>
    <span class="n">z_r_points</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">getYieldSurfacePointsAll_RprimeZ</span><span class="p">(</span><span class="n">X_eff</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">sqrtKG</span><span class="p">,</span> <span class="n">I1eff_min</span><span class="p">,</span> <span class="n">I1eff_max</span><span class="p">,</span>
                                     <span class="n">num_points</span><span class="p">,</span> <span class="n">z_r_points</span><span class="p">);</span>

    <span class="c1">// Find the closest point</span>
    <span class="n">findClosestPoint</span><span class="p">(</span><span class="n">z_r_pt</span><span class="p">,</span> <span class="n">z_r_points</span><span class="p">,</span> <span class="n">z_r_closest</span><span class="p">);</span>

    <span class="c1">// Compute I1 for the closest point</span>
    <span class="kt">double</span> <span class="n">I1eff_closest</span> <span class="o">=</span> <span class="n">sqrt_three</span><span class="o">*</span><span class="n">z_r_closest</span><span class="p">.</span><span class="n">x</span><span class="p">();</span>

    <span class="c1">// If (I1_closest &lt; I1_mid)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">I1eff_closest</span> <span class="o">&lt;</span> <span class="n">I1eff_mid</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">I1eff_max</span> <span class="o">=</span> <span class="n">I1eff_mid</span><span class="p">;</span>
      <span class="n">eta_hi</span> <span class="o">=</span> <span class="n">eta_mid</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">I1eff_min</span> <span class="o">=</span> <span class="n">I1eff_mid</span><span class="p">;</span>
      <span class="n">eta_lo</span> <span class="o">=</span> <span class="n">eta_mid</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">I1eff_mid</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">I1eff_min</span> <span class="o">+</span> <span class="n">I1eff_max</span><span class="p">);</span>
    <span class="n">eta_mid</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">eta_lo</span> <span class="o">+</span> <span class="n">eta_hi</span><span class="p">);</span>

    <span class="c1">// Distance to old closest point</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iters</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">z_r_closest</span> <span class="o">-</span> <span class="n">z_r_closest_old</span><span class="p">).</span><span class="n">length2</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1.0e-16</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">z_r_closest_old</span> <span class="o">=</span> <span class="n">z_r_closest</span><span class="p">;</span>

    <span class="o">++</span><span class="n">iters</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The yield surface points are computed using</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span></span><span class="kt">void</span>
<span class="n">YieldCond_MasonSand</span><span class="o">::</span><span class="n">getYieldSurfacePointsAll_RprimeZ</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">X_eff</span><span class="p">,</span>
                                                      <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">kappa</span><span class="p">,</span>
                                                      <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">sqrtKG</span><span class="p">,</span>
                                                      <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">I1eff_min</span><span class="p">,</span>
                                                      <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">I1eff_max</span><span class="p">,</span>
                                                      <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">num_points</span><span class="p">,</span>
                                                      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;&amp;</span> <span class="n">z_r_vec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Compute z_eff and r&#39;</span>
  <span class="n">computeZeff_and_RPrime</span><span class="p">(</span><span class="n">X_eff</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">sqrtKG</span><span class="p">,</span> <span class="n">I1eff_min</span><span class="p">,</span> <span class="n">I1eff_max</span><span class="p">,</span> <span class="n">num_points</span><span class="p">,</span> <span class="n">z_r_vec</span><span class="p">);</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span>
<span class="n">YieldCond_MasonSand</span><span class="o">::</span><span class="n">computeZeff_and_RPrime</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">X_eff</span><span class="p">,</span>
                                            <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">kappa</span><span class="p">,</span>
                                            <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">sqrtKG</span><span class="p">,</span>
                                            <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">I1eff_min</span><span class="p">,</span>
                                            <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">I1eff_max</span><span class="p">,</span>
                                            <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">num_points</span><span class="p">,</span>
                                            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;&amp;</span> <span class="n">z_r_vec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Set up points</span>
  <span class="kt">double</span> <span class="n">rad</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">d_local</span><span class="p">.</span><span class="n">PEAKI1</span> <span class="o">-</span> <span class="n">X_eff</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">cen</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">d_local</span><span class="p">.</span><span class="n">PEAKI1</span> <span class="o">+</span> <span class="n">X_eff</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">theta_max</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">acos</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">((</span><span class="n">I1eff_min</span> <span class="o">-</span> <span class="n">cen</span><span class="p">)</span><span class="o">/</span><span class="n">rad</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">));</span>
  <span class="kt">double</span> <span class="n">theta_min</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">acos</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">((</span><span class="n">I1eff_max</span> <span class="o">-</span> <span class="n">cen</span><span class="p">)</span><span class="o">/</span><span class="n">rad</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">));</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">theta_vec</span><span class="p">;</span>
  <span class="n">linspace</span><span class="p">(</span><span class="n">theta_min</span><span class="p">,</span> <span class="n">theta_max</span><span class="p">,</span> <span class="n">num_points</span><span class="p">,</span> <span class="n">theta_vec</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">theta</span> <span class="p">:</span> <span class="n">theta_vec</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">I1_eff</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">cen</span> <span class="o">+</span> <span class="n">rad</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">X_eff</span><span class="p">);</span>


    <span class="c1">// Compute F_f</span>
    <span class="kt">double</span> <span class="n">Ff</span> <span class="o">=</span> <span class="n">d_local</span><span class="p">.</span><span class="n">a1</span> <span class="o">-</span> <span class="n">d_local</span><span class="p">.</span><span class="n">a3</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">exp</span><span class="p">(</span><span class="n">d_local</span><span class="p">.</span><span class="n">a2</span><span class="o">*</span><span class="n">I1_eff</span><span class="p">)</span> <span class="o">-</span> <span class="n">d_local</span><span class="p">.</span><span class="n">a4</span><span class="o">*</span><span class="p">(</span><span class="n">I1_eff</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">Ff_sq</span> <span class="o">=</span> <span class="n">Ff</span><span class="o">*</span><span class="n">Ff</span><span class="p">;</span>

    <span class="c1">// Compute Fc</span>
    <span class="kt">double</span> <span class="n">Fc_sq</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">I1_eff</span> <span class="o">&lt;</span> <span class="n">kappa</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">double</span> <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">kappa</span> <span class="o">-</span> <span class="n">I1_eff</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">kappa</span> <span class="o">-</span> <span class="n">X_eff</span><span class="p">);</span>
      <span class="n">Fc_sq</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">ratio</span><span class="o">*</span><span class="n">ratio</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Compute J2</span>
    <span class="kt">double</span> <span class="n">J2</span> <span class="o">=</span> <span class="n">Ff_sq</span><span class="o">*</span><span class="n">Fc_sq</span><span class="p">;</span>
    <span class="n">z_r_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">I1_eff</span><span class="o">/</span><span class="n">sqrt_three</span><span class="p">,</span>
                            <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">J2</span><span class="p">)</span><span class="o">*</span><span class="n">sqrtKG</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>And, finally, the actual geometric closest point algorithm is</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span></span><span class="kt">void</span>
<span class="n">YieldCond_MasonSand</span><span class="o">::</span><span class="n">findClosestPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;&amp;</span> <span class="n">poly</span><span class="p">,</span>
                                      <span class="n">Point</span><span class="o">&amp;</span> <span class="n">min_p</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">TOLERANCE_MIN</span> <span class="o">=</span> <span class="mf">1.0e-12</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">XP</span><span class="p">;</span>

  <span class="c1">// Loop through the segments of the polyline</span>
  <span class="k">auto</span> <span class="n">iterStart</span> <span class="o">=</span> <span class="n">poly</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">iterEnd</span>   <span class="o">=</span> <span class="n">poly</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">iterNext</span> <span class="o">=</span> <span class="n">iterStart</span><span class="p">;</span>
  <span class="o">++</span><span class="n">iterNext</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">iterNext</span> <span class="o">!=</span> <span class="n">iterEnd</span><span class="p">;</span> <span class="o">++</span><span class="n">iterStart</span><span class="p">,</span> <span class="o">++</span><span class="n">iterNext</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Point</span> <span class="n">start</span> <span class="o">=</span> <span class="o">*</span><span class="n">iterStart</span><span class="p">;</span>
    <span class="n">Point</span> <span class="n">next</span>  <span class="o">=</span> <span class="o">*</span><span class="n">iterNext</span><span class="p">;</span>

    <span class="c1">// Find shortest distance from point to the polyline line</span>
    <span class="n">Vector</span> <span class="n">m</span> <span class="o">=</span> <span class="n">next</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
    <span class="n">Vector</span> <span class="n">n</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">length2</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">TOLERANCE_MIN</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">XP</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">double</span> <span class="n">t0</span> <span class="o">=</span> <span class="n">Dot</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">Dot</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">t0</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">XP</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t0</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">XP</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Shortest distance is inside segment; this is the closest point</span>
        <span class="n">min_p</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">t0</span> <span class="o">+</span> <span class="n">start</span><span class="p">;</span>
        <span class="n">XP</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">min_p</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">double</span> <span class="n">min_d</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">xp</span> <span class="p">:</span>  <span class="n">XP</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Compute distance sq</span>
    <span class="kt">double</span> <span class="n">dSq</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">xp</span><span class="p">).</span><span class="n">length2</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dSq</span> <span class="o">&lt;</span> <span class="n">min_d</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">min_d</span> <span class="o">=</span> <span class="n">dSq</span><span class="p">;</span>
      <span class="n">min_p</span> <span class="o">=</span> <span class="n">xp</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h5 id="an-animation-of-the-closest-point-algorithm">An animation of the closest point algorithm</h5>
<div class="yield-surf-canvas">
</div>

<h4 id="remarks">Remarks</h4>
<p>This geometric algorithm is remarkably accurate and avoids complications associated with
computing gradients in the transformed space.  In the next article we will discuss
how the animation in this was created.</p>

<p>If you have questions/comments/corrections, please contact banerjee at parresianz dot com dot zen (without the dot zen).</p>

<p><a class="twitter-share-button" href="https://twitter.com/intent/tweet" data-via="parresianz"> Tweet</a>
<script src="//platform.linkedin.com/in.js" type="text/javascript">
  lang: en_US
</script>
<script type="IN/Share" data-counter="right"></script></p>

<script src="https://d3js.org/d3.v4.min.js"></script>

<script src="https://bbanerjee.github.io/ParSim/assets/js/yieldsurface.js"></script>

<script>
  d3.json("https://bbanerjee.github.io/ParSim/assets/json/yieldSurfData.json", drawYieldSurface);
</script>


          





  
  

  
  

  
  

  
  

  
  


        </article>
      </div>

      <div class="unit one-fifth hide-on-mobiles">
  <aside>
    
    <h4>Getting Started</h4>
    <ul>

  
  
  <li class=""><a href="https://bbanerjee.github.io/ParSim/docs/home/">Welcome</a></li>

  
  
  <li class=""><a href="https://bbanerjee.github.io/ParSim/docs/quickstart/">Quick-start guide</a></li>

  
  
  <li class=""><a href="https://bbanerjee.github.io/ParSim/docs/installation/">Installation</a></li>

</ul>

    
    <h4>Vaango tutorials</h4>
    <ul>

  
  
  <li class=""><a href="https://bbanerjee.github.io/ParSim"></a></li>

</ul>

    
    <h4>Vaango manuals</h4>
    <ul>

  
  
  <li class=""><a href="https://bbanerjee.github.io/ParSim"></a></li>

</ul>

    
  </aside>
</div>


      <div class="clear"></div>

    </div>
  </section>


  <footer>
  <div class="grid">
    <div class="unit one-third center">
      <p>&copy;&nbsp;2017 under the terms of the <a href="https://github.com/bbanerjee/ParSim/blob/master/LICENSE">MIT&nbsp;License</a>.</p>
    </div>
    <div class="unit one-third align-right center">
      <p>
        Built with
        <a href="https://jekyllrb.com">
          <img src="https://bbanerjee.github.io/ParSim/assets/img/logo-2x.png" width = "70" height="30" alt="Jekyll">
        </a>
      </p>
    </div>
    <div class="unit one-third align-right center">
      <p>
        Hosted by
        <a href="https://github.com">
          <img src="https://bbanerjee.github.io/ParSim/assets/img/footer-logo.png" width="100" height="30" alt="GitHub • Social coding">
        </a>
      </p>
    </div>
  </div>
</footer>

  <script>
  var anchorForId = function (id) {
    var anchor = document.createElement("a");
    anchor.className = "header-link";
    anchor.href      = "#" + id;
    anchor.innerHTML = "<span class=\"sr-only\">Permalink</span><i class=\"fa fa-link\"></i>";
    anchor.title = "Permalink";
    return anchor;
  };

  var linkifyAnchors = function (level, containingElement) {
    var headers = containingElement.getElementsByTagName("h" + level);
    for (var h = 0; h < headers.length; h++) {
      var header = headers[h];

      if (typeof header.id !== "undefined" && header.id !== "") {
        header.appendChild(anchorForId(header.id));
      }
    }
  };

  document.onreadystatechange = function () {
    if (this.readyState === "complete") {
      var contentBlock = document.getElementsByClassName("docs")[0] || document.getElementsByClassName("news")[0];
      if (!contentBlock) {
        return;
      }
      for (var level = 1; level <= 6; level++) {
        linkifyAnchors(level, contentBlock);
      }
    }
  };
</script>

  
</body>
</html>
