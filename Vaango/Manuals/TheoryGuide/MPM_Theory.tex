\chapter{The Material Point Method} \label{ch:MPMTheory}

\section{Introduction}

The \MPM component solves the momentum equations
\Beq
  \Div{\Bsig} + \rho\Bb = \rho\dot{\Bv} 
\Eeq
using an updated Lagrangian formulation. The momentum solve for solid materials is
complicated by the fact that the equations need material constitutive models for
closure.  These material constitutive models vary significantly between materials
and contribute a large fraction of the computational cost of a simulation.

The material point method (MPM) was described by Sulsky et al.~\cite{Sulsky1994,Sulsky1995} as
an extension to the FLIP (Fluid-Implicit Particle) method of
Brackbill~\cite{brackbill-ruppel86}, which itself is an
extension of the particle-in-cell (PIC) method of
Harlow~\cite{harlow1963}.  Interestingly, the name ``material point method"
first appeared in the literature two years later in a description of
an axisymmetric form of the method~\cite{sulsky_axisym_1996}.  In both
FLIP and MPM, the basic idea is the same: objects are discretized into
particles, or material points, each of which contains all state data for the
small region of material that it represents.  This includes the position, mass, volume,
velocity, stress and state of deformation of that material.  MPM differs from
other so called ``mesh-free" particle methods in that, while each object
is primarily represented by a collection of particles, a computational mesh
is also an important part of the calculation.  Particles do not interact
with each other directly, rather the particle information is accumulated
to the grid, where the equations of motion are integrated forward in time.
This time advanced solution is then used to update the particle state.

The method usually uses a regular structured grid as a computational mesh.
While this grid, in principle, deforms as the material that it is representing
deforms, at the end of each timestep, it is reset to its original undeformed
position, in effect providing a new computational grid for each timestep.
The use of a regular structured grid for each time step has a number of
computational advantages.  Computation of spatial gradients is simplified.
Mesh entanglement, which can plague fully Lagrangian techniques, such as
the Finite Element Method (FEM), is avoided.  MPM has also been successful
in solving problems involving contact between colliding objects, having an
advantage over FEM in that the use of the regular grid eliminates the
need for doing costly searches for contact surfaces\cite{Bard2000}.

In addition to the advantages that MPM brings, as with any numerical technique, it has its own set of shortcomings.  It is computationally more
expensive than a comparable FEM code.  Accuracy for MPM is typically lower
than FEM, and errors associated with particles moving around the computational
grid can introduce non-physical oscillations into the solution.  Finally,
numerical difficulties can still arise in simulations involving large
deformation that will prematurely terminate the simulation.  The severity of
all of these issues (except for the expense) has been significantly reduced
with the introduction of the Generalized Interpolation Material Point Method,
or GIMP\cite{Bard2004}.  The basic concepts associated with GIMP will be
described below.  Throughout this document, MPM (which
ends up being a special case of GIMP) will frequently be referred to
interchangably with GIMP.

In addition, MPM can be incorporated with a multi-material CFD algorithm
as the structural component in a fluid-structure interaction formulation.
This capability was first demonstrated in the CFDLIB codes from
Los Alamos by Bryan Kashiwa and co-workers\cite{Kashiwa2000}.  There, as
in the Uintah-MPMICE component,
MPM serves as the Lagrangian description of the solid
material in a multimaterial CFD code.  Certain elements of the
solution procedure are based in the Eulerian CFD algorithm, including
intermaterial heat and momentum transfer as well as satisfaction
of a multimaterial equation of state.  The use of a Lagrangian method
such as MPM to advance the solution of the solid material eliminates
the diffusion typically associated with Eulerian methods.  The Uintah-MPM
component will be described in later chapter of this manual.

Subsequent sections of this chapter will first give a relatively brief
description of the MPM and GIMP algorithms.  This will, of course, be
focused mainly on describing the capabilities of the Uintah-MPM component.
This is followed by a section that attempts to relate the information in
Section~\ref{Sec:AlgDesc} to the implementation in Uintah.
Following that is a description of the information that goes into an input
file.  Finally, a number of examples are provided, along with representative
results.

\section{Algorithm Description} \label{Sec:AlgDesc}

Time and space prohibit an exhaustive description of the theoretical
underpinnings of the Material Point Method.   Here we will concentrate
on the discrete equations that result from applying a weak form analysis
to the governing equations.  The interested reader should
consult \cite{Sulsky1994,Sulsky1995} for the development of these discrete
equations in MPM, and \cite{Bard2004} for the development of the equations
for the GIMP method.  These end up being very similar, the differences in
how the two developments affect implementation will be described in
Section~\ref{gimp_mpm}.

In solving a structural mechanics problem with MPM, one begins by discretizing
the object of interest into a suitable number of particles, or ``material
points".  ({\bf Aside:}  What constitutes a suitable number is something of an open
question, but it is typically advisable to use at least two particles in each
computational cell in each direction, i.e. 4 particles per cell (PPC) in 2-D,
8 PPC in 3-D. In choosing the resolution of the computational grid, similar
considerations apply as for any computational method (trade-off between
time to solution and accuracy, use of resolution studies to ensure convergence
in results, etc.).)  Each of these particles will carry, minimally, the
following variables:
\begin{itemize}

\item position - $\bfx_p$
\item mass - $m_p$
\item volume - $v_p$
\item velocity - $\bfv_p$
\item stress - $\sig_p$ 
\item deformation gradient - $\bfF_p$

\end{itemize}

The description that follows is a recipe for advancing each of these
variables from the current (discrete) time $n$ to the subsequent
time $n+1$.  Note that particle mass, $m_p$, typically remains constant
throughout a simulation unless solid phase reaction models are utilized,
a feature that is not present in Uintah-MPM.  (Such models are available
in MPMICE, see Section \ref{ch:MPMICE}.)  It is also important to point
out that the algorithm for advancing the timestep is based on the so-called
Update Stress Last (USL) algorithm.  The superiority of this approach over
the Update Stress First (USF) approach was clearly demonstrated by Wallstedt
and Guilkey \cite{WallstedtJCP}.  USF was the formulation used in Uintah
until mid-2008.

The discrete momentum equation that results from the weak form is given as:
\begin{eqnarray}
        \bfm \bfa &=& \bfF^{\rm{ext}} - \bfF^{\rm{int}}  \label{newton2}
\end{eqnarray}
where $\bfm$ is the mass matrix, $\bfa$ is the acceleration vector,
$\bfF^{\rm{ext}}$ is the external force vector (sum of the body forces and
tractions), and $\bfF^{\rm{int}}$ is the internal force vector resulting from
the divergence of the material stresses.  The construction of each of these
quantities, which are based at the nodes of the computational grid,
will be described below.

The solution begins by accumulating the particle state on the
nodes of the computational grid, to form the mass matrix $\bfm$ and to find
the nodal external forces $\bfF^{\rm{ext}}$, and velocities,
$\bfv$.  In practice, a lumped mass matrix is used to avoid the need to
invert a system of equations to solve Eq. \ref{newton2} for acceleration.
These quantities are calculated at individual nodes by the following equations,
where the $\sum\limits_{p}$ represents a summation over all particles:
\begin{eqnarray}
m_i = \sum_{p} S_{ip} m_p,  \;\;\;\;\;\; 
\bfv_i = \frac{\sum\limits_{p} S_{ip} m_p \bfv_p}{m_i},  \;\;\;\;\;\;
\bfF^{\rm{ext}}_i &=& \sum_{p} S_{ip} \bfF^{\rm{ext}}_p
\label{accumulate}
\end{eqnarray}
and $i$ refers to individual nodes of the grid.  $m_p$ is the particle
mass, $\bfv_p$ is the particle velocity, and $\bfF^{\rm{ext}}_p$ is the
external force on the particle.  The external forces that start on the
particles typically the result of tractions, the application of which is
discussed in the \Vaango User manual.
$S_{ip}$ is the shape function of the $ith$ node evaluated at $\bfx_p$.
The functional form of the shape functions differs between MPM and GIMP.
This difference is discussed in Section \ref{gimp_mpm}.

Following the operations in Eq.~\ref{accumulate}, $\bfF^{\rm{int}}$
is still required in order to solve for acceleration at the nodes.
This is computed at the nodes as a volume integral of the divergence
of the stress on the particles, specifically:

\begin{eqnarray}
\bfF^{\rm{int}}_i &=& \sum_{p} \bfG_{ip} \sig_p v_p,
\label{computeIntForce}  
\end{eqnarray}
where $\bfG_{ip}$ is the gradient of the shape function of the $ith$ node
evaluated at $\bfx_p$, and $\sig_p$ and $v_p$ are the time $n$ values of
particle stress and volume respectively.  

Equation \ref{newton2} can then be solved for $\bfa$.
\begin{eqnarray}
\bfa_i &=& \frac{\bfF_i^{\rm{ext}} - \bfF_i^{\rm{int}}}{m_i}
\label{MPM:acceleration}
\end{eqnarray}
An explicit forward Euler method is used for the time integration:
\begin{eqnarray}
\bfv_i^L= \bfv_i + \bfa_i \Delta{t}
\label{MPM:euler}
\end{eqnarray}

The time advanced grid velocity, $\bfv^L$ is used to compute a velocity
gradient at each particle according to:

\begin{equation}
\nabla \bfv_p = \sum_i \bfG_{ip} \bfv^L_i
\label{velgrad}
\end{equation}
This velocity gradient is used to update the particle's deformation gradient,
volume and stress.  First, an incremental deformation gradient is computed
using the velocity gradient:

\begin{equation}
\bfd \bfF_p^{n+1} = (\bfI+\nabla \bfv_p \Delta{t})
\label{Finc}
\end{equation}
Particle volume and deformation gradient are updated by:

\begin{eqnarray}
v_p^{n+1} = \rm{Det}(\bfd\bfF_p^{n+1})v_p^n,  \;\;\;\;\;\;\;\;\;
\bfF_p^{n+1}=\bfd\bfF_p^{n+1} \bfF_{p}^{n}
\label{p_vol}
\end{eqnarray}
Finally, the velocity gradient, and/or the deformation gradient are
provided to a constitutive model, which outputs a time advanced stress
at the particles.  

At this point in the timestep, the particle position and velocity are explicitly
updated by:
\begin{eqnarray}
\bfv_p (t + \Delta{t})  &=& \bfv_p (t)  + \sum_{i} S_{ip} \bfa_i  \Delta{t} 
\label{MPM:updateVp}
\end{eqnarray}
\begin{eqnarray}
\bfx_p (t + \Delta{t})  &=& \bfx_p (t)  + \sum_{i} S_{ip} \bfv^L_i  \Delta{t}
\label{MPM:updateXp}
\end{eqnarray}
This completes one timestep, in that the update of all six of the variables
enumerated above (with the exception of mass, which is assumed to remain
constant) has been accomplished.  Conceptually, one can imagine that, since an
acceleration and velocity were computed at the grid, and an interval of time
has passed, the grid nodes also experienced a displacement.  This 
displacement also moved the particles in an isoparametric fashion.  In
practice, particle motion is accomplished by Equation~\ref{MPM:updateXp},
and the grid never deforms.  So, while the MPM literature will often refer
to resetting the grid to its original configuration, in fact, this 
isn't necessary as the grid nodes never leave that configuration.  Regardless,
at this point, one is ready to advance to the next timestep.

The algorithm described above is the core of the Uintah-MPM implementation.
However, it neglects a number of important considerations.  The first is
kinematic boundary conditions on the grid for velocity and acceleration.
Next, is the use of advanced contact
algorithms.  By default, MPM enforces no-slip, no-interpenetration contact.
This feature is extremely useful, but it also means that two bodies initially
in ``contact" (meaning that they both contain particles whose data are
accumulated to common nodes) behave as if they are a single body.  To enable
multi-field simulations with frictional contact, or to impose displacement
based boundary conditions, e.g. a rigid piston, additional steps must be
taken.  These steps implement contact formulations such as that described
by Bardenhagen, et al.\cite{Bard2001}.  The {\it use} of the contact
algorithms is described briefly in this manual, but the reader will be
referred to the relevant literature for their development.  Lastly, heat
conduction is also available in the explicit MPM code, although it may be
neglected via a run time option in the input file.  Explicit MPM is typically
used for high rate simulations in which heat conduction is negligible.

\section{Shape functions for MPM and GIMP} \label{gimp_mpm}

In both MPM and GIMP, the basic idea is the same: objects are discretized into
particles, or material points, each of which contains all state data for the
small region of material that it represents.  In MPM, these particles are spatially
Dirac delta functions, meaning that the material that each represents is
assumed to exist at a single point in space, namely the position of the
particle.  Interactions between the particles and the grid take place
using weighting functions, also known as shape functions or interpolation
functions.  These are typically, but not necessarily, linear, bilinear or
trilinear in one, two and three dimensions, respectively.

More recently, Bardenhagen and Kober~\cite{Bard2004} generalized the
development that gives rise to MPM, and suggested that MPM
may be thought of as a subset of their ``Generalized Interpolation
Material Point" (GIMP) method.  In the family of GIMP methods
one chooses a characteristic function $\chi_p$ to represent
the particles and a shape function $S_i$ as a basis of support on the
computational nodes.  An effective shape function $\bar{S}_{ip}$  is found
by the convolution of the $\chi_p$ and $S_i$ which is written as:
\begin{equation}
\bar{S}_{ip}(\bfx_p) = \frac{1}{V_p}  \int_{\Omega_p \cap \Omega} \chi_p(\bfx - \bfx_p) S_i(\bfx)\,\mathrm{d}\bfx .
\label{effectiveS}
\end{equation}
While the user has significant latitude in choosing
these two functions, in practice, the choice of $S_i$ is usually given
(in one-dimension) as,
\begin{equation}
S_i\left(x\right) = \begin{cases} 1 + {\left(x-x_i\right) / h} & {-h < x-x_i \le 0} \\
                    1 - {\left(x-x_i\right) / h} & {0  < x-x_i \le h} \\
                    0 & \text{otherwise},
       \end{cases}
\label{linear_shape}
\end{equation}
where $x_i$ is the vertex location, and $h$ is the cell width, 
assumed to be constant in this formulation, 
although this is not a general restriction on the method.
Multi-dimensional versions are constructed by forming tensor products of the
one-dimensional version in the orthogonal directions.  

When the choice of characteristic function is the Dirac delta,
\begin{equation}
\chi_p(\bfx) = \delta(\bfx-\bfx_p)V_p , \label{MPM_char}
\end{equation}
where $\bfx_p$ is the particle position, and $V_p$ is the particle volume,
then traditional MPM is recovered.  In that case, the effective shape function
is still that given by Equation~\ref{linear_shape}.  Its gradient is given by:

\begin{equation}
G_i\left(x\right) = \begin{cases} {1 / h} & {-h < x-x_i \le 0} \\
                    {-1 / h} & {0  < x-x_i \le h} \\
                    0 & \text{otherwise},
       \end{cases}
\label{linear_shape_grad}
\end{equation}

Plots of Equations~\ref{linear_shape} and~\ref{linear_shape_grad} are shown
below.  The discontinuity in the gradient gives rise to poor accuracy and
stability properties.

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{mpm_basis.pdf}
  \caption{Effective shape function when using traditional MPM.}
  \label{Fig:MPMShape}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{mpm_grad.pdf}
  \caption{Gradient of the effective shape function when using traditional MPM.}
  \label{Fig:MPMShapeGrad}
\end{figure}

Typically, when an analyst indicates that
they are ``using GIMP" this implies use of the linear grid basis function
given in Eq.~\ref{linear_shape} and a ``top-hat" characteristic function,
given by (in one-dimension),
\begin{equation}
\chi_p(x) = H(x-(x_p-l_p))-H(x-(x_p+l_p)) , \label{GIMP_char}
\end{equation}
where $H(x)$ is the Heaviside function
($H(x)=0$ if $x<0$ and $H(x)=1$ if $x\ge0$) and $l_p$ is the half-length
of the particle.  When the convolution indicated in Eq.~\ref{effectiveS}
is carried out using the expressions in Eqns.~\ref{linear_shape}
 and~\ref{GIMP_char}, a closed form for the effective shape function can be
written as:
\begin{equation}
S_{i}\left(x_p\right) = \begin{cases}
   \frac{\left(h+l_p+\left(x_p-x_i\right)\right)^2}{4hl_p} & {-h -l_p < x_p-x_i \le -h+l_p} \\
   1 + \frac{\left(x_p-x_i\right)}{h} & {-h + l_p < x_p-x_i \le -l_p} \\
   1 - \frac{\left(x_p-x_i\right)^2 + l_p^2}{2hl_p} & {-l_p < x_p-x_i \le l_p} \\
   1 - \frac{\left(x_p-x_i\right)}{h} & {l_p  < x_p-x_i \le h-l_p} \\
   \frac{\left(h+l_p-\left(x_p-x_i\right)\right)^2}{4hl_p} & {h -l_p < x_p-x_i \le h+l_p} \\
   0 & \text{otherwise},
\end{cases}
\label{gimp_shape}
\end{equation}
%
The gradient of which is:
\begin{equation}
G_i(x_p) = \begin{cases}
   \frac{h+l_p+\left(x_p-x_i\right)}{2 h l_p} & {-h -l_p < x_p-x_i \le -h+l_p} \\
   \frac{1}{h} & {-h + l_p < x_p-x_i \le -l_p} \\
   - \frac{\left(x_p-x_i\right)}{h l_p} & {-l_p < x_p-x_i \le l_p} \\
   - \frac{1}{h} & {l_p  < x_p-x_i \le h-l_p} \\
   - \frac{h+l_p-\left(x_p-x_i\right)}{2 h l_p} & {h -l_p < x_p-x_i \le h+l_p} \\
   0 & \text{otherwise},
\end{cases}
\label{gimpGrad}
\end{equation}

Plots of Equations~\ref{gimp_shape} and~\ref{gimpGrad} are shown
below.  The continuous nature of the gradients are largely responsible
for the improved robustness and accuracy of GIMP over MPM.

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{gimp_basis.pdf}
  \caption{Effective shape function when using GIMP.}
  \label{Fig:GIMP}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{gimp_grad.pdf}
  \caption{Gradient of the effective shape function when using GIMP.}
  \label{Fig:GradGIMP}
\end{figure}
%
There is one further consideration in defining the effective shape function,
and that is whether or not the size (length in 1-D) of the particle is kept
fixed (denoted as ``UGIMP" here)
or is allowed to evolve due to material deformations 
(``Finite GIMP" or ``Contiguous GIMP" in (1) and ``cpGIMP" here).
In one-dimensional
simulations, evolution of the particle (half-)length is straightforward,
\begin{equation}
l_p^n = F_p^n l_p^0 ,  \label{particle_length}
\end{equation} 
where $F_p^n$ is the deformation gradient at time $n$.
In multi-dimensional simulations, a similar approach can be used, assuming
an initially rectangular or cuboid particle, to find the current particle
shape.  The difficulty arises in evaluating Eq.~\ref{effectiveS} for
these general shapes.  One approach, apparently effective, has been to create
a cuboid that circumscribes the deformed particle shape~\cite{jinmaCMES2006}.
Alternatively, one can assume that the particle size remains constant (insofar
as it applies to the effective shape function evaluations only).  This is
the approach currently implemented in Uintah.

\section{Pseudocode of MPM algorithm in Vaango}
The momentum equation is solved using the MPM algorithm while forward Euler time-stepping
is use to integrate time derivatives.  The pseudocode of the overall algorithm is given below.
The main quantities of interest are:
\begin{itemize} 
  \setlength\itemsep{1pt}
  \item $t_\Tmax$ : {\Ochre The maximum time until which the simulation is to run.}
  \item $t, \Delta t$ : {\Ochre The current time ($t = t_n$) and the time step.}
  \item $\Bh_g$ : {\Ochre The grid spacing vector.}
  \item $m_p$ : {\Ochre The particle mass.}
  \item $V_p^n, V_p^{n+1}$ : {\Ochre The particle volume at $t = t_n$ and $t = t_{n+1}$.}
  \item $\Bx_p^n, \Bx_p^{n+1}$ : {\Ochre The particle position at $t = t_n$ and $t = t_{n+1}$.}
  \item $\Bu_p^n, \Bu_p^{n+1}$ : {\Ochre The particle displacement at $t = t_n$ and $t = t_{n+1}$.}
  \item $\Bv_p^n, \Bv_p^{n+1}$ : {\Ochre The particle velocity at $t = t_n$ and $t = t_{n+1}$.}
  \item $\Bsig_p^n, \Bsig_p^{n+1}$ : {\Ochre The particle Cauchy stress at time $t = t_n$ and $t = t_{n+1}$.}
  \item $\BF_p^n, \BF_p^{n+1}$ : {\Ochre The particle deformation gradient at time $t = t_n$ and $t = t_{n+1}$.}
\end{itemize}

\subsection{Initialization}
An outline of the initialization process is described below.  Specific details have been 
discussed in earlier reports. The new quantities introduced in this section are
\begin{itemize} 
  \setlength\itemsep{1pt}
  \item $n_p$ : {\Ochre The number of particles used to discretize a body.}
  \item $\Bb_p^n, \Bb_p^{n+1}$ : {\Ochre The particle body force acceleration at $t = t_n$ and $t = t_{n+1}$.}
  \item $D_p^n, D_p^{n+1}$ : {\Ochre The particle damage parameter at $t = t_n$ and $t = t_{n+1}$.}
  \item $\Bf_p^{\Text,n}, \Bf_p^{\Text,n+1}$ : {\Ochre The particle external force at $t = t_n$ and $t = t_{n+1}$.}
\end{itemize}
\begin{breakablealgorithm}
  \caption{Initialization}
  \begin{algorithmic}[1]
    \Require \TTObj{xmlProblemSpec}, \TTObj{defGradComputer}, \TTObj{constitutiveModel}, 
             \TTObj{damageModel}, \TTObj{particleBC},\WRP 
             \TTObj{mpmFlags} \TTList{materialList}, 
    \Procedure{initialize}{}
      \For{\TTmatl\, \textbf{in} \TTList{materialList}}
        \State $n_p$[\TTmatl], $\Bx^0_p$[\TTmatl], $\Bu^0_p$[\TTmatl], $m_p$[\TTmatl], 
             $V^0_p$[\TTmatl], $\Bv^0_p$[\TTmatl], $\Bb^0_p$[\TTmatl], \WRP
             $\Bf^{\Text,0}_p$[\TTmatl] $\leftarrow$ \TTmatl.\textsc{createParticles}()
        \State $\BF^0_p$[\TTmatl] $\leftarrow$ \TTObj{defGradComputer}.\textsc{initialize}(\TTmatl)
        \State $\Bsig^0_p$[\TTmatl] $\leftarrow$ \TTObj{constitutiveModel}.\textsc{initialize}(\TTmatl)
        \State $D^0_p$[\TTmatl] $\leftarrow$ \TTObj{damageModel}.\textsc{initialize}(\TTmatl)
      \EndFor
      \If {\TTObj{mpmFlags}.initializeStressWithBodyForce = TRUE}
        \State $\Bb^0_p \leftarrow$ \textsc{initializeBodyForce}()
        \State $\Bsig^0_p, \BF^0_p$ $\leftarrow$ \textsc{initializeStressAndDefGradFromBodyForce}()
      \EndIf
      \If {\TTObj{mpmFlags}.applyParticleBCs = TRUE}
        \State $\Bf^{\Text,0}_p$ $\leftarrow$ \TTObj{particleBC}.\textsc{initializePressureBCs}()
      \EndIf
      \State \Return $n_p$, $\Bx^0_p$, $\Bu^0_p$, $m_p$, 
             $V^0_p$, $\Bv^0_p$, $\Bb^0_p$, $\Bf^{\Text,0}_p$, $\BF^0_p$, $\Bsig^0_p$, $D^0_p$
    \EndProcedure
  \end{algorithmic}
\end{breakablealgorithm}

\subsection{Time advance}
The operations performed during a timestep are shown in the pseudocode below.
\begin{breakablealgorithm}
  \caption{The MPM time advance algorithm}
  \begin{algorithmic}[1]
    \Procedure{timeAdvance}{$\Bh_g$, $x^n_p$, $u^n_p$, $m_p$, $V^n_p$, $\Bv^n_p$, $\Bf^{\Text,n}_p$,
                            $\BdT^n_p$}%, $\Bsig^n_p$}%, $\BF^n_p$}
      \State $\Bb_p^n \leftarrow$ \textsc{computeParticleBodyForce}()
        \Comment{Compute the body force term}
      \State $\Bf_p^{\Text,n+1} \leftarrow$ \textsc{applyExternalLoads}()
        \Comment{Apply external loads to the particles}
      \State $m_g$, $V_g$, $\Bv_g$, $\Bb_g$, $\Bf^\Text_g$ $\leftarrow $ 
        \textsc{interpolateParticlesToGrid}()
        \Comment{Interpolate particle data to the grid}
      \State \textsc{exchangeMomentumInterpolated}()
        \Comment{Exchange momentum between bodies on grid. \WRP Not discussed in this report.}
      \State $\Bf^\Tint_g$, $\Bsig_g$, $\Bv_g$ $\leftarrow$ \textsc{computeInternalForce}()
        \Comment{Compute the internal force at the grid nodes}
      \State $\Bv_g^\star$, $\Ba_g$ $\leftarrow$ \textsc{computeAndIntegrateAcceleration}()
        \Comment{Compute the grid velocity \WRP and grid acceleration}
      \State \textsc{exchangeMomentumIntegrated}()
        \Comment{Exchange momentum between bodies on grid \WRP using integrated values.  
                 Not discussed in this report.}
      \State $\Bv_g^\star$, $\Ba_g$ $\leftarrow$ \textsc{setGridBoundaryConditions}()
        \Comment{Update the grid velocity and grid \WRP acceleration using the BCs}
      \State $\BlT_p^n$, $\BF_p^{n+1}$, $V_p^{n+1}$ $\leftarrow$ \textsc{computeDeformationGradient}()
        \Comment{Compute the velocity gradient \WRP and the deformation gradient}
      \State $\Bsig_p^{n+1}$, $\Beta_p^{n+1}$ $\leftarrow$ \textsc{computeStressTensor}()
        \Comment{Compute the updated stress and \WRP internal variables (if any)}
      \State $\Bsig_p^{n+1}$, $\Beta_p^{n+1}$, $\chi_p^{n+1}$, $D_p^{n+1}$ $\leftarrow$ 
        \textsc{computeBasicDamage}()
        \Comment{Compute the damage parameter \WRP and update the stress and internal variables}
      \State $\chi_p^{n+1}$, $D_p^{n+1}$ $\leftarrow$ \textsc{updateErosionParameter}()
        \Comment{Update the indicator variable that is used \WRP to delete particles at the
                 end of a time step}
      \State $V_p^{n+1}$, $\Bu_p^{n+1}$, $\Bv_p^{n+1}$, $\Bx_p^{n+1}$, $m_p$, $\Bh_p^{n+1}$ $\leftarrow$
        \textsc{interpolateToParticlesAndUpdate}()
        \Comment{Update the \WRP particle variables after interpolating grid quantities to particles}
    \EndProcedure
  \end{algorithmic}
\end{breakablealgorithm}
The algorithms used for the above operations are discussed next.

\subsubsection{Computing the body force}
The body force consists of a gravitational term and, optionally, centrifugal and coriolis terms
that are needed for simulations inside a rotating frame such as a centrifuge.
\begin{breakablealgorithm}
  \caption{Computing the body force on particles}
  \begin{algorithmic}[1]
    \Require $\Bx_p^n$, $\Bv_p^n$, \TTList{materialList}, \TTList{particleList}, \TTObj{mpmFlags}
    \Procedure{computeParticleBodyForce}{}
      \For{\TTmatl\, \textbf{in} \TTList{materialList}}
        \If {\TTObj{mpmFlags}.\texttt{rotatingCoordSystem} = TRUE}
           \State $\Bg \leftarrow$ \TTObj{mpmFlags}.\texttt{gravityAcceleration}
           \State $\Bb_p^{n}$[\TTmatl] $\leftarrow$ $\Bg$
        \Else
          \For{\TTpart\, \textbf{in} \TTList{particleList}}
             \State $\Bg \leftarrow$ \TTObj{mpmFlags}.\texttt{gravityAcceleration}
             \State $\Bx_{rc} \leftarrow$ \TTObj{mpmFlags}.\texttt{coordRotationCenter}
             \State $\Bz_r \leftarrow$ \TTObj{mpmFlags}.\texttt{coordRotationAxis}
             \State $w \leftarrow$ \TTObj{mpmFlags}.\texttt{coordRotationSpeed}
             \State $\Bomega \leftarrow w\Bz_r$
               \Comment{Compute angular velocity vector}
             \State $\Ba_{\text{corolis}} \leftarrow 2 \Bomega \times \Bv_p^{n}[\TTmatl,\TTpart]$
               \Comment{Compute Coriolis acceleration}
             \State $\Br \leftarrow \Bx_p^{n}[\TTmatl,\TTpart] - \Bx_{rc}$
             \State $\Ba_{\text{centrifugal}} \leftarrow \Bomega \times \Bomega \times \Br$
               \Comment{Compute the centrifugal body force acceleration}
             \State $\Bb_p^{n}$[\TTmatl,\TTpart] $\leftarrow$ 
                $\Bg -\Ba_{\text{centrifugal}} - \Ba_{\text{coriolis}}$
               \Comment{Compute the body force acceleration}
          \EndFor
        \EndIf
      \EndFor
      \State \Return $\Bb_p^{n}$
    \EndProcedure
  \end{algorithmic}
\end{breakablealgorithm}

\subsubsection{Applying external loads}
Note that the updated deformation gradient has not been computed yet at this stage and the 
particle force is applied based on the deformation gradient at the beginning of the timestep.
The new quantities introduced in this section are:
\begin{itemize} 
  \setlength\itemsep{1pt}
  \item $\Bh_p^n$ : {\Ochre The particle size matrix at time $t = t_n$.}
\end{itemize}
\begin{breakablealgorithm}
  \caption{Applying external loads to particles}
  \begin{algorithmic}[1]
    \Require $t_{n+1}$, $\Bx_p^n$, $\Bh_p^n$, $\Bu_p^n$, $\Bf^{\Text,n}_p$, $\BF_p^n$,
             \TTList{materialList}, \TTList{particleList}, 
             \TTObj{mpmFlags}, \TTObj{particleBC}
    \Procedure{applyExternalLoads}{}
      \State $f_p$ $\leftarrow$ $0$
      \If {\TTObj{mpmFlags}.\texttt{useLoadCurves} = TRUE}
        \State $f_p$ $\leftarrow$ \TTObj{particleBC}.\textsc{computeForcePerParticle}($t^{n+1}$)
        \Comment{Compute the force per particle \WRP due to the applied pressure}
      \EndIf
      \For{\TTmatl\, \textbf{in} \TTList{materialList}}
        \If {\TTObj{mpmFlags}.\texttt{useLoadCurves} = TRUE}
          \For{\TTpart\, \textbf{in} \TTList{particleList}}
            \State $\Bf^{\Text,n+1}_p$[\TTmatl,\TTpart] $\leftarrow$ 
               \TTObj{particleBC}.\textsc{getForceVector}($t_{n+1}$, $\Bx_p^n$, $\Bh_p^n$, $\Bu_p^n$, \WWRP
                  $f_p$, $\BF_p^{n}$)
               \Comment{Compute the applied force vector at each particle}
          \EndFor
        \Else
          \State $\Bf^{\Text,n+1}_p$[\TTmatl] $\leftarrow$ $\Bf^{\Text,n}_p$[\TTmatl]
        \EndIf
      \EndFor
      \State \Return $\Bf_p^{\Text,n+1}$
    \EndProcedure
  \end{algorithmic}
\end{breakablealgorithm}

\subsubsection{Interpolating particles to grid}
The grid quantities computed during this procedure and not stored for the next timestep except for
the purpose of visualization.  The new quantities introduced in this section are
\begin{itemize} 
  \setlength\itemsep{1pt}
  \item $m_g$ : {\Ochre The mass at a grid node.}
  \item $V_g$ : {\Ochre The volume at a grid node.}
  \item $\Bv_g$ : {\Ochre The velocity at a grid node.}
  \item $\Bf^\Text_g$ : {\Ochre The external force at a grid node.}
  \item $\Bb_g$ : {\Ochre The body force at a grid node.}
\end{itemize}
\begin{breakablealgorithm}
  \caption{Interpolating particle data to background grid}
  \begin{algorithmic}[1]
    \Require $m_p$, $V_p^n$, $\Bx_p^n$, $\Bh_p^n$, $\Bb_p^n$, $\Bf^{\Text,n+1}_p$, $\BF_p^n$,
             \TTList{materialList}, \TTList{particleList}, \TTList{gridNodeList}
             \TTObj{mpmFlags}, \TTObj{particleBC}
    \Procedure{interpolateParticlesToGrid}{}
      \State \TTObj{interpolator} $\leftarrow$ \textsc{createInterpolator}(\TTObj{mpmFlags})
        \Comment{Create the interpolator \WRP and find number of grid nodes that can affect a particle}
      \For{\TTmatl\, \textbf{in} \TTList{materialList}}
        \For{\TTpart\, \textbf{in} \TTList{particleList}}
          \State $n_{gp}$, $S_{gp}$ $\leftarrow$ 
            \TTObj{interpolator}.\textsc{findCellsAndWeights}($\Bx_p^n$, $\Bh_p^n$, $\BF_p^n$)
            \Comment{Find the node \WWRP indices of the cells affecting the particle and the 
                     interpolation weights}
          \State $\Bp_p$ $\leftarrow$ $m_p$[\TTmatl][\TTpart] $\Bv_p^n$[\TTmatl][\TTpart] 
            \Comment{Compute particle momentum}
          \For{\TTnode\, \textbf{in} $n_{gp}$}
            \State $m_g$[\TTmatl][\TTnode] $\leftarrow$ $m_g$[\TTmatl][\TTnode] + $m_p$[\TTmatl][\TTpart] $S_{gp}$[\TTnode]
            \State $V_g$[\TTmatl][\TTnode] $\leftarrow$ $V_g$[\TTmatl][\TTnode] + $V_p^n$[\TTmatl][\TTpart] $S_{gp}$[\TTnode]
            \State $\Bv_g$[\TTmatl][\TTnode] $\leftarrow$ $\Bv_g$[\TTmatl][\TTnode] + $\Bp_p$ $S_{gp}$[\TTnode]
            \State $\Bf^{\Text}_g$[\TTmatl][\TTnode] $\leftarrow$ $\Bf^{\Text}_g$[\TTmatl][\TTnode] + $\Bf^{\Text,n+1}_p$[\TTmatl][\TTpart] $S_{gp}$[\TTnode]
            \State $\Bb_g$[\TTnode] $\leftarrow$ $\Bb_g$[\TTnode] + $m_p$[\TTmatl][\TTpart] $\Bb^n_p$[\TTmatl][\TTpart] $S_{gp}$[\TTnode]
          \EndFor
        \EndFor
        \For{\TTnode\, \textbf{in} \TTList{gridNodeList}}
          \State $\Bv_g$[\TTmatl][\TTnode] $\leftarrow$ $\Bv_g$[\TTmatl][\TTnode]/$m_g$[\TTmatl][\TTnode]
        \EndFor
        \State $\Bv_g$[\TTmatl] $\leftarrow$ \textsc{applySymmetryVelocityBC}($\Bv_g$[\TTmatl])
          \Comment{Apply any symmetry \WRP velocity BCs that may be applicable}
      \EndFor
      \State \Return $m_g$, $V_g$, $\Bv_g$, $\Bb_g$, $\Bf_g^{\Text}$
    \EndProcedure
  \end{algorithmic}
\end{breakablealgorithm}

\subsubsection{Exchanging momentum using interpolated grid values}
The exchange of momentum is carried out using a contact model.  Details can be found in the
Uintah Developers Manual.

\subsubsection{Computing the internal force}
This procedure computes the internal force at the grid nodes. The new quantities introduced in this 
section are
\begin{itemize} 
  \setlength\itemsep{1pt}
  \item $n_{gp}$ : {\Ochre The number of grid nodes that are used to interpolate from particle to grid.}
  \item $S_{gp}$ : {\Ochre The nodal interpolation function evaluated at a particle}
  \item $\BG_{gp}$ : {\Ochre The gradient of the nodal interpolation function evaluated at a particle}
  \item $\Bsig_v$ : {\Ochre A volume weighted grid node stress.}
  \item $\Bf^\Tint_g$ : {\Ochre The internal force at a grid node.}
\end{itemize}
\begin{breakablealgorithm}
  \caption{Computing the internal force}
  \begin{algorithmic}[1]
    \Require $\Bh_g$, $V_g$, $V_p^n$, $\Bx_p^n$, $\Bh_p^n$, $\Bsig_p^n$, $\BF_p^n$,
             \TTList{materialList}, \TTList{particleList}, \TTList{gridNodeList}
             \TTObj{mpmFlags}
    \Procedure{computeInternalForce}{}
      \State \TTObj{interpolator} $\leftarrow$ \textsc{createInterpolator}(\TTObj{mpmFlags})
        \Comment{Create the interpolator and \WRP find number of grid nodes that can affect a particle}
      \For{\TTmatl\, \textbf{in} \TTList{materialList}}
        \For{\TTpart\, \textbf{in} \TTList{particleList}}
          \State $n_{gp}$, $S_{gp}$, $\BGv_{gp}$ $\leftarrow$   \WWRP
            \TTObj{interpolator}.\textsc{findCellsAndWeightsAndShapeDervatives}($\Bx_p^n$, $\Bh_p^n$, $\BF_p^n$) \WWRP
            \Comment{Find the node indices of the cells affecting the particle and \WWRP the 
                     interpolation weights and gradients}
          \State $\Bsig_v$ $\leftarrow$ $V_p$[\TTmatl][\TTpart] $\Bsig_p^n$[\TTmatl][\TTpart] 
          \For{\TTnode\, \textbf{in} $n_{gp}$}
            \State $\Bf^{\Tint}_g$[\TTmatl][\TTnode] $\leftarrow$ $\Bf^{\Tint}_g$[\TTmatl][\TTnode] - 
               ($\BGv_{gp}$[\TTnode]$/\Bh_g$) $\cdot \Bsig_p^n$[\TTmatl][\TTpart] $V_p^n$[\TTpart]
            \State $\Bsig_g$[\TTmatl][\TTnode] $\leftarrow$ $\Bsig_g$[\TTmatl][\TTnode] + $\Bsig_v$ $S_{gp}$[\TTnode]
          \EndFor
        \EndFor
        \For{\TTnode\, \textbf{in} \TTList{gridNodeList}}
          \State $\Bsig_g$[\TTmatl][\TTnode] $\leftarrow$ $\Bsig_g$[\TTmatl][\TTnode]/$V_g$[\TTmatl][\TTnode]
        \EndFor
        \State $\Bv_g$[\TTmatl] $\leftarrow$ \textsc{applySymmetryTractionBC}()
          \Comment{Apply any symmetry tractions BCs \WWRP that may be applicable}
      \EndFor
      \State \Return $\Bf_g^{\Tint}$, $\Bsig_g$, $\Bv_g$
    \EndProcedure
  \end{algorithmic}
\end{breakablealgorithm}

\subsubsection{Computing and integrating the acceleration}
This procedure computes the accelerations at the grid nodes and integrates the grid accelerations
using forward Euler to compute grid velocities. The new quantities introduced in this section are
\begin{itemize} 
  \setlength\itemsep{1pt}
  \item $\Ba_{g}$ : {\Ochre The grid accelerations.}
  \item $\Bv_{g}^\star$ : {\Ochre The integrated grid velocities.}
\end{itemize}
\begin{breakablealgorithm}
  \caption{Computing and integrating the acceleration}
  \begin{algorithmic}[1]
    \Require $\Delta t$, $m_g$, $\Bf^{\Tint}_g$, $\Bf^{\Text}_g$, $\Bb_g$, $\Bv_g$,
             \TTList{materialList}, \TTList{gridNodeList},
             \TTObj{mpmFlags}
    \Procedure{computeAndIntegrateAcceleration}{}
      \For{\TTmatl\, \textbf{in} \TTList{materialList}}
        \For{\TTnode\, \textbf{in} \TTList{gridNodeList}}
          \State $\Ba_g$[\TTmatl][\TTnode] $\leftarrow$ 
            ($\Bf^{\Tint}_g$[\TTmatl][\TTnode] +
             $\Bf^{\Text}_g$[\TTmatl][\TTnode] + 
             $\Bb_g$[\TTmatl][\TTnode])$/m_g$[\TTmatl][\TTnode]
          \State $\Bv_g^{\star}$ $\leftarrow$ $\Bv_g$[\TTmatl][\TTnode] + 
            $\Ba_g$[\TTmatl][\TTnode] $* \Delta t$
        \EndFor
      \EndFor
      \State \Return $\Bv_g^{\star}$, $\Ba_g$
    \EndProcedure
  \end{algorithmic}
\end{breakablealgorithm}

\subsubsection{Exchanging momentum using integrated grid values}
The exchange of momentum is carried out using a contact model.  Details can be found in the
Uintah Developers Manual.

\subsubsection{Setting grid boundary conditions}
\begin{breakablealgorithm}
  \caption{Setting grid boundary conditions}
  \begin{algorithmic}[1]
    \Require $\Delta t$, $\Ba_g$, $\Bv_g^{\star}$, $\Bv_g$,
             \TTList{materialList}, \TTList{gridNodeList},
             \TTObj{mpmFlags}
    \Procedure{setGridBoundaryConditions}{}
      \For{\TTmatl\, \textbf{in} \TTList{materialList}}
        \State $\Bv_g^\star$[\TTmatl] $\leftarrow$ \textsc{applySymmetryVelocityBC}($\Bv_g^\star$[\TTmatl])
        \For{\TTnode\, \textbf{in} \TTList{gridNodeList}}
          \State $\Ba_g$[\TTmatl][\TTnode] $\leftarrow$ ($\Bv_g^\star$[\TTmatl][\TTnode] - $\Bv_g$[\TTmatl][\TTnode]) $/ \Delta t$
        \EndFor
      \EndFor
      \State \Return $\Bv_g^\star$, $\Ba_g$
    \EndProcedure
  \end{algorithmic}
\end{breakablealgorithm}

\subsubsection{Computing the deformation gradient}
The velocity gradient is computed using the integrated grid velocities and then used to 
compute the deformation gradient. The new quantities introduced in this section are
\begin{itemize} 
  \setlength\itemsep{1pt}
  \item $\Delta\BF_{p}^n$ : {\Ochre The increment of the particle deformation gradient.}
  \item $\BlT_p^{n+1}$ : {\Ochre The particle velocity gradient.}
  \item $\rho_0$ : {\Ochre The initial mass density of the material.}
\end{itemize}
\begin{breakablealgorithm}
  \caption{Computing the velocity gradient and deformation gradient}
  \begin{algorithmic}[1]
    \Require $\Delta t$, $\Bx_p^n$, $m_p$, $V_p^n$, $\Bh_p^n$, $\Bv_p^n$, $\BlT_p^n$, $\BF_p^n$,
             $\Bh_g$, $\Bv_g$, $\Bv_g^\star$, $\rho_0$
             \TTList{materialList}, \TTList{gridNodeList},
             \TTObj{mpmFlags}, \TTObj{velGradComputer}
    \Procedure{computeDeformationGradient}{}
      \State \TTObj{interpolator} $\leftarrow$ \textsc{createInterpolator}(\TTObj{mpmFlags})
      \For{\TTmatl\, \textbf{in} \TTList{materialList}}
        \For{\TTpart\, \textbf{in} \TTList{particleList}}
          \State $\BlT_p^{n+1}$[\TTmatl,\TTpart] $\leftarrow$ 
           \TTObj{velGradComputer}.\textsc{computeVelGrad}(\TTObj{interpolator},
            $\Bh_g$, $\Bx_p^n$[\TTmatl,\TTpart], \WWRP
            $\Bh_p^n$[\TTmatl,\TTpart], $\BF_p^n$[\TTmatl,\TTpart], 
            $\Bv_g^\star$[\TTmatl])
            \Comment{Compute the velocity gradient}
          \State $\BF_p^{n+1}$[\TTmatl,\TTpart], $\Delta \BF_p^{n+1}$ $\leftarrow$ 
            \textsc{computeDeformationGradientFromVelocity}($\BlT_p^n$[\TTmatl,\TTpart], \WWRP
            $\BlT_p^{n+1}$[\TTmatl,\TTpart], $\BF_p^n$[\TTmatl,\TTpart])
            \Comment{Compute the deformation gradient}
          \State $V_p^{n+1}$[\TTmatl,\TTpart] $\leftarrow$ $m_p$[\TTmatl,\TTpart]/$\rho_0$ 
            $*\det(\BF_p^{n+1}$[\TTmatl,\TTpart])
        \EndFor
      \EndFor
      \State \Return $\BlT_p^{n+1}$, $\BF_p^{n+1}$, $V_p^{n+1}$
    \EndProcedure
  \end{algorithmic}
\end{breakablealgorithm}

\begin{breakablealgorithm}
  \caption{Computing the deformation gradient using the velocity gradient}
  \begin{algorithmic}[1]
    \Require $\Delta t$, $\BlT_p^{n+1}$, $\BF_p^n$,
             \TTObj{mpmFlags}
    \Procedure{computeDeformationGradientFromVelocity}{}
      \If {\TTObj{mpmFlags}.\texttt{defGradAlgorithm} = \texttt{"first\_order"}}
         \State $\BF_p^{n+1}$, $\Delta\BF_p^{n+1}$  $\leftarrow$ 
           \textsc{seriesUpdateConstantVelGrad}(\texttt{numTerms} = 1, $\Delta t$, $\BlT_p^{n+1}$, $\BF_p^n$) 
      \ElsIf {\TTObj{mpmFlags}.\texttt{defGradAlgorithm} = \texttt{"subcycle"}}
         \State $\BF_p^{n+1}$, $\Delta\BF_p^{n+1}$  $\leftarrow$
           \textsc{subcycleUpdateConstantVelGrad}($\Delta t$, $\BlT_p^{n+1}$, $\BF_p^n$) 
      \ElsIf {\TTObj{mpmFlags}.\texttt{defGradAlgorithm} = \texttt{"taylor\_series"}}
         \State $\BF_p^{n+1}$, $\Delta\BF_p^{n+1}$  $\leftarrow$
           \textsc{seriesUpdateConstantVelGrad}(\texttt{numTerms} = \TTObj{mpmFlags}.\texttt{numTaylorSeriesTerms}, 
              $\Delta t$, $\BlT_p^{n+1}$, $\BF_p^n$) 
      \Else
         \State $\BF_p^{n+1}$, $\Delta\BF_p^{n+1}$  $\leftarrow$
           \textsc{cayleyUpdateConstantVelGrad}($\Delta t$, $\BlT_p^{n+1}$, $\BF_p^n$) 
      \EndIf
      \State \Return $\BF_p^{n+1}$, $\Delta\BF_p^{n+1}$ 
    \EndProcedure
  \end{algorithmic}
\end{breakablealgorithm}

\subsubsection{Computing the stress tensor}
The stress tensor is compute by individual constitutive models.  Details of the Arena partially
saturated model are given later. The new quantities introduced in this section are
\begin{itemize} 
  \setlength\itemsep{1pt}
  \item $\Beta_p^n, \Beta_p^{n+1}$ : {\Ochre The internal variables needed by the constitutive model.}
\end{itemize}
\begin{breakablealgorithm}
  \caption{Computing the stress tensor}
  \begin{algorithmic}[1]
    \Require $\Delta t$, $\Bx_p^n$, $m_p$, $V_p^{n+1}$, $\Bh_p^n$, $\BlT_p^{n+1}$, $\BF_p^{n+1}$,
             $\Bsig_p^n$, $\Beta_p^n$, $\rho_0$, \TTList{materialList}, \TTObj{mpmFlags}, \TTObj{constitutiveModel}
    \Procedure{computeStressTensor}{}
      \For{\TTmatl\, \textbf{in} \TTList{materialList}}
        \State $\Bsig^{n+1}$, $\Beta_p^{n+1}$ $\leftarrow$
          \TTObj{constitutiveModel}[\TTmatl].\textsc{computeStressTensor}($\Delta t$, $\Bx_p^n$, $m_p$, 
             $V_p^{n+1}$, $\Bh_p^n$, \WWRP 
             $\BlT_p^{n+1}$, $\BF_p^{n+1}$, $\Bsig_p^n$, $\Beta_p^n$, $\rho_0$, \TTObj{mpmFlags})
          \Comment{Update the stress and any \WWRP internal variables needed by the constitutive model}
      \EndFor
      \State \Return $\Bsig_p^{n+1}$, $\Beta_p^{n+1}$
    \EndProcedure
  \end{algorithmic}
\end{breakablealgorithm}

\subsubsection{Computing the basic damage parameter}
The damage parameter is updated and the particle stress is modified in this procedure. The new 
quantities introduced in this section are
\begin{itemize} 
  \setlength\itemsep{1pt}
  \item $\Veps_p^{f,n}, \Veps_p^{f,n+1}$ : {\Ochre The particle strain to failure at $t = T_n$ 
        and $t = T_{n+1}$.}
  \item $\chi_p^{n}, \chi_p^{n+1}$ : {\Ochre An indicator function that identifies whether a particle
        has failed completely.} 
  \item $t_p^{\chi,n}, t_p^{\chi,n+1}$ : {\Ochre The time to failure of a particle.}
  \item $D_p^{n}, D_p^{n+1}$ : {\Ochre A particle damage parameter that can be used to modify the stress.}
\end{itemize}
\begin{breakablealgorithm}
  \caption{Computing the damage parameter}
  \begin{algorithmic}[1]
    \Require $t^{n+1}$, $V_p^{n+1}$, $\BF_p^{n+1}$, $\Bsig_p^{n+1}$, $D_p^n$, $\Veps_p^{f,n}$, $\chi^n_p$, 
             $t^{\chi,n}_p$,
             \TTList{materialList}, \TTObj{mpmFlags}
    \Procedure{computeDamage}{}
      \For{\TTmatl\, \textbf{in} \TTList{materialList}}
        \For{\TTpart\, \textbf{in} \TTList{particleList}}
          \If {\texttt{brittleDamage} = TRUE} 
            \State $\Bsig_p^{n+1}$, $\Veps_p^{f,n+1}$, $\chi^{n+1}_p$, $t^{\chi,n+1}_p$, $D_p^{n+1}$ $\leftarrow$
               \textsc{updateDamageAndModifyStress}($V_p^{n+1}$, $\BF_p^{n+1}$, \WWRP 
                  $\Bsig_p^{n+1}$, $D_p^n$, $\Veps_p^{f,n}$, $\chi^n_p$, $t^{\chi,n}_p$)
             \Comment{Update the damage parameters and stress}
          \Else
            \State $\Bsig_p^{n+1}$, $\Veps_p^{f,n+1}$, $\chi^{n+1}_p$, $t^{\chi,n+1}_p$ $\leftarrow$
               \textsc{updateFailedParticlesAndModifyStress}($V_p^{n+1}$, $\BF_p^{n+1}$, \WWRP 
                  $\Bsig_p^{n+1}$, $\Veps_p^{f,n}$, $\chi^n_p$, $t^{\chi,n}_p$, $t^{n+1}$)
             \Comment{Update the failed particles and stress}
          \EndIf
        \EndFor
      \EndFor
      \State \Return $\Bsig_p^{n+1}$, $\Veps_p^{f,n+1}$, $\chi^{n+1}_p$, $t^{\chi,n+1}_p$, $D_p^{n+1}$
    \EndProcedure
  \end{algorithmic}
\end{breakablealgorithm}

\subsubsection{Updating the particle erosion parameter}
The particle failure indicator function is updated in this procedure and used later for 
particle deletion if needed.
\begin{breakablealgorithm}
  \caption{Updating the particle erosion parameter}
  \begin{algorithmic}[1]
    \Require $D_p^n$, $\chi^n_p$
             \TTList{materialList}, \TTObj{mpmFlags}, \TTObj{constitutiveModel}
    \Procedure{updateErosionParameter}{}
      \For{\TTmatl\, \textbf{in} \TTList{materialList}}
        \For{\TTpart\, \textbf{in} \TTList{particleList}}
          \If {\TTmatl.\texttt{doBasicDamage} = TRUE} 
            \State $\chi^{n+1}_p$ $\leftarrow$
               \TTObj{damageModel}.\textsc{getLocalizationParameter}()
             \Comment{Just get the indicator \WWRP parameter for particles that will be eroded.}
          \Else
            \State $\chi^{n+1}_p$, $D_p^{n+1}$ $\leftarrow$
               \TTObj{constitutiveModel}[\TTmatl].\textsc{getDamageParameter}($\chi^n_p$, $D^n_p$)
             \WWRP \Comment{Update the damage parameter in the constitutive model.}
          \EndIf
        \EndFor
      \EndFor
      \State \Return $\chi^{n+1}_p$, $D_p^{n+1}$
    \EndProcedure
  \end{algorithmic}
\end{breakablealgorithm}

\subsubsection{Interpolating back to the particles and update}
This is the final step at which the particle velocities and positions are updated and the grid
is reset.  Particle that are to be removed are dealt with in a subsequent \texttt{relocation} step.
\begin{breakablealgorithm}
  \caption{Interpolating back to the particles and position update}
  \begin{algorithmic}[1]
    \Require $\Delta t$, 
             $\Ba_g$, $\Bv_g^\star$, $\Bx_p^n$, $\Bv_p^n$, $\Bu_p^n$, $\Bh_p^n$, $\chi_p^{n+1}$, $\BF_p^{n+1}$,
             $V_p^{n+1}$,
             \TTList{materialList}, \TTList{particleList}, \TTList{gridNodeList}, \TTObj{mpmFlags}
    \Procedure{interpolateToParticlesAndUpdate}{}
      \State \texttt{interpolator} $\leftarrow$ \textsc{createInterpolator}(\TTObj{mpmFlags})
      \For{\TTmatl\, \textbf{in} \TTList{materialList}}
        \State $\Bh_p^{n+1}$ $\leftarrow$ $\Bh_p^n$
        \For{\TTpart\, \textbf{in} \TTList{particleList}}
          \State $n_{gp}$, $S_{gp}$ $\leftarrow$ 
            \texttt{interpolator}.\textsc{findCellsAndWeights}($\Bx_p^n$, $\Bh_p^{n+1}$, $\BF_p^{n+1}$)
          \State $\Bv$ $\leftarrow$ $\Bzero$,~~ $\Ba$ $\leftarrow$ $\Bzero$,~
          \For{\TTnode\, \textbf{in} \TTList{gridNodeList}}
            \State $\Bv$ $\leftarrow$ $\Bv$ + $\Bv_g^\star$[\TTnode] $*$ $S_{gp}$[\TTnode]
              \Comment{Update particle velocity}
            \State $\Ba$ $\leftarrow$ $\Ba$ + $\Ba_g$[\TTnode] $*$ $S_{gp}$[\TTnode]
              \Comment{Update particle acceleration}
          \EndFor
          \State $\Bx_p^{n+1}$ $\leftarrow$ $\Bx_p^n$ + $\Bv * \Delta t$
            \Comment{Update position}
          \State $\Bu_p^{n+1}$ $\leftarrow$ $\Bu_p^n$ + $\Bv * \Delta t$
            \Comment{Update displacement}
          \State $\Bv_p^{n+1}$ $\leftarrow$ $\Bv_p^n$ + $\Ba * \Delta t$
            \Comment{Update velocity}
        \EndFor
      \EndFor
      \State \textsc{deleteRogueParticles}()
        \Comment{Delete particles that are to be eroded.}
      \State \Return $V_p^{n+1}$, $\Bu_p^{n+1}$, $\Bv_p^{n+1}$, $\Bx_p^{n+1}$, $m_p$, $\Bh_p^{n+1}$
    \EndProcedure
  \end{algorithmic}
\end{breakablealgorithm}

