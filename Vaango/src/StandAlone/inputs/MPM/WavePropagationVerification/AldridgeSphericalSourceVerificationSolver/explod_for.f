ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc                                                                   cc
cc                 Program:  EXPLOD_FOR                              cc
cc                 Primary Developer: D.F. Aldridge                  cc
cc                 Last Revision Date:  21 April 2004                cc
cc                                                                   cc
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc
cc  Program EXPLOD_FOR calculates displacement, velocity, acceleration,
cc  or pressure traces generated by a spherical cavity source with
cc  nonzero radius "rs".  This source may be activated with either
cc  a prescribed radial displacement, velocity, acceleration, stress,
cc  or pressure applied to its surface.  The spherical source is 
cc  situated a homogeneous and isotropic elastic or acoustic 
cc  wholespace, and the solution method (frequency domain) assumes 
cc  complete spherical symmetry.
cc
cc  Run parameters:
cc
cc  Earth model parameters:
cc
cc     alfa - P-wave speed.
cc     beta - S-wave speed.
cc     rho  - mass density.
cc
cc  Trace parameters:
cc
cc      tmin - minimum time.
cc      dt   - time increment.
cc      tlen - trace duration.
cc
cc  Source parameters:
cc
cc      xs,ys,zs - position coordinates of center of source sphere. 
cc      rs    - radius of source sphere.
cc      samp  - source amplitude scalar.
cc      stype - flag for interpreting source waveform:
cc          stype=0: radial displacement waveform.
cc          stype=1: radial velocity waveform.
cc          stype=2: radial acceleration waveform.
cc          stype=4: radial stress waveform.
cc          stype=5: pressure waveform.
cc
cc  Receiver parameters:
cc
cc      nr - number of receivers.
cc
cc      For EACH receiver (ir=1,nr) input one line of parameters:
cc
cc      rtype - receiver type flag.
cc      xr,yr,zr - receiver position coordinates
cc      ramp  - receiver output amplitude scalar.
cc      theta - polar angle of receiver sensitivity axis (deg).
cc      phi   - azimuthal angle of receiver sensitivity axis (deg).
cc
cc  Trace plot parameters:
cc
cc      tscale - time scalar.
cc      dscale - distance scalar.
cc      ascale - amplitude scalar.
cc      iplot  - plot option flag: Select coordinate for output trace
cc                                 plotting.
cc               iplot=1: x-coordinate
cc               iplot=2: y-coordinate
cc               iplot=3: z-coordinate
cc               iplot=4: receiver number
cc               iplot=0: no coordinate
cc
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc        
cc  Input/Output:
cc
cc     1) Run parameters are read from file #1.
cc     2) Source waveform is read from file #2.
cc     3) Calculated traces are written to file #3.
cc
cc  Compilation:
cc
cc     Unix command "f77 explod_for.f -o explod_for.exe" generates 
cc     a compiled code file named "explod_for.exe" from Fortran 77
cc     source code file named "explod_for.f".
cc
cc  Memory Allocation:
cc
cc     Two parameters controlling array dimensioning are set via
cc     "parameter" statements:
cc         nf_dim - maximum number of frequencies.
cc         nr_dim - maximum number of receivers.
cc    
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Define array dimensions.
c
      parameter (nf_dim=1000001)
      parameter (nr_dim=101)
c
c  Dimension arrays and declare variables.
c
      complex*8 spect(nf_dim),spect_s(nf_dim)
      real*4 data(nf_dim),wavelet(nf_dim)
      real*4 receivers(nr_dim,8)
      complex*8 zero,one,eye,arg,aprox,
     &          dtod,stoa_acoustic_dc,stod_acoustic
c
c  Define constants.
c
      pi=3.141592653589794
      pi2=2.0*pi
      zero=cmplx(0.0,0.0)
      one =cmplx(1.0,0.0)
      eye =cmplx(0.0,1.0)
c
c  Read run parameters from file #1 and perform validity checks.
c
      call run_param (
     i                nr_dim,
     o                alfa,beta,rho,
     o                tmin,dt,tlen,
     o                xs,ys,zs,rs,samp,stype,
     o                receivers,nr,
     o                tscale,dscale,ascale,iplot)
c
c  Write diagnostic information to standard output.
c
      write (6,9000)
 9000 format (/,15x,'Spherical Cavity Forward Modeling Program',
     &           1x,'EXPLOD_FOR')
      write (6,9001)
 9001 format (/,10x,'Earth model:')
      write (6,9002) alfa,beta,rho
 9002 format (15x,'P-wave speed = ',f8.2,4x,'S-wave speed = ',f8.2,
     &         4x,'Mass density = ',f8.2)

      write (6,9003) 
 9003 format (10x,'Spherical source parameters:')
      write (6,9004) xs,ys,zs
 9004 format (15x,'x-coordinate =  ',f8.3,5x,
     &            'y-coordinate =  ',f8.3,5x,
     &            'z-coordinate =  ',f8.3)
      write (6,9005) rs
 9005 format (15x,'radius       =  ',f8.3)
      write (6,9006) samp
 9006 format (15x,'amplitude    =  ',f16.3)

      if (stype.eq.0.0) write (6,9007)
      if (stype.eq.1.0) write (6,9008)
      if (stype.eq.2.0) write (6,9009)
      if (stype.eq.4.0) write (6,9010)
      if (stype.eq.5.0) write (6,9011)
 9007 format (15x,'type:        radial displacement')
 9008 format (15x,'type:        radial velocity')
 9009 format (15x,'type:        radial acceleration')
 9010 format (15x,'type:        radial stress')
 9011 format (15x,'type:        pressure')

      write (6,9015)
 9015 format (10x,'Trace parameters:')
      write (6,9016) tmin
 9016 format (15x,'Start time      = ',f9.7,' s')
      write (6,9017) tlen
 9017 format (15x,'Duration        = ',f9.7,' s')
      write (6,9018) dt
 9018 format (15x,'Sample interval = ',f9.7,' s')
c
c  Calculate number of samples in trace (round up to nearest integer).
c
      nsamps_io=(tlen/dt)+1.5
c
c  Increase number of samples to the next integer power of 2.
c
      nsamps=2
      do 10 k=2,16
      n1=2**(k-1)
      n2=2**k
      if ((n1.lt.nsamps_io).and.(n2.ge.nsamps_io)) then
          nsamps=n2
          go to 11
      endif
   10 continue
   11 continue
c
c   Check that array size is adequate.
c
      if ((2*nsamps).gt.nf_dim) then
          write (6,9020)
 9020     format (10x,'Too many samples!  Increase array size.')
          write (6,9021)
 9021     format (10x,'nsamps = ',i8,4x,'nf_dim = ',i8)
          stop
      endif
c
c  Calculate frequency sampling interval and number of discrete
c  frequencies.
c
      df=1.0/(nsamps*dt)
      nf=(nsamps/2)+1
      
c
c  Write more diagnostic information to standard output.
c
      write (6,9022) nsamps_io
 9022 format (/,15x,'Number of trace samples requested  = ',i6)
      write (6,9023) nsamps
 9023 format (15x,'Number of samples in padded trace  = ',i6)
      write (6,9024) df
 9024 format (15x,'Frequency sampling interval        = ',f8.2,' Hz')
      write (6,9025) 1.0/(2.0*dt)
 9025 format (15x,'Nyquist frequency                  = ',f10.2,' Hz')
      write (6,9026) nf-2
 9026 format (15x,'Number of positive frequencies     = ',i6)
c
c  Read source wavelet from file #2; note that file #2 may contain
c  either two or three columns of numbers.
c
      do 20 it=1,nsamps_io
   20 read (2,*) dummy,wavelet(it)
cc   20 read (2,*) dummy,dummy,wavelet(it)
c
c  Fourier transform source waveform to frequency domain.
c  First, initialize a real-valued work array.
c
      do 25 it=1,nsamps
      kk=2*it-1
      data(kk)  =0.0
   25 data(kk+1)=0.0
c
c  Load (real-valued) source waveform into every other word of
c  work array.
c
      do 30 it=1,nsamps_io
      kk=2*it-1
   30 data(kk)=wavelet(it)
c
c  Calculate forward FFT of work array.
c
      isign=-1
      call four1 (
     i            nf_dim,
     i            nsamps,isign,
     b            data)
c
c  Store real and imaginary parts of the Fourier spectrum as a
c  complex-valued source spectrum.  Note multiplication by time
c  sample interval dt to put spectrum into proper physical dimension.
c
      do 40 if=1,nf
      kk=2*if-1
   40 spect_s(if)=cmplx(data(kk),data(kk+1))*dt
c
c  Logic is utilized to address the case of a "prescribed pressure
c  source".  For an elastic medium, pressure differs from radial 
c  stress, whereas in an acoustic medium they are identical. 
c  Pressure source formulae are nearly identical to transfer
c  functions for radial stress source, but with shear speed
c  "beta" equal to zero.
c
      divisor=1.0
      if (stype.eq.5.0) then
c
c  Reset source type flag to 4.0 (radial stress source).
c
          stype_input=stype
          stype=4.0
c
c  Calculate a divisor, and then reset shear speed to zero.
c
          gamma=beta/alfa
          if (gamma.eq.(sqrt(3.0)/2.0)) then
              write (6,9030)
 9030         format (/,15x,'Invalid Vs/Vp ratio for pressure source!')
              stop
          endif
          divisor=1.0-(4.0/3.0)*gamma**2
          beta_input=beta
          beta=0.0

      endif
c
c  Address each receiver.
c
      do 100 ir=1,nr
c
c  Retreive receiver type.
c
      rtype=receivers(ir,1) 
c
c  Retrieve receiver position coordinates.
c
      xr=receivers(ir,2)
      yr=receivers(ir,3)
      zr=receivers(ir,4)
c
c  Retrieve receiver amplitude scalar.
c
      ramp=receivers(ir,8)
c
c  Calculate radial distance from center of source sphere to receiver.
c
      r=sqrt((xr-xs)**2+(yr-ys)**2+(zr-zs)**2)
c
c  Calculate frequency-domain transfer functions.
c
c  Treat displacement/velocity/acceleration receivers first.
c
      if (rtype.lt.4.0) then
c
c  Displacement source (velocity and acceleration sources
c  are treated by differentiation option).
c
          if (stype.lt.4.0) then

              call trans_dtod (
     i                         nf_dim,
     i                         df,nf,
     i                         alfa,
     i                         rs,r,
     o                         spect)

              iexpo=rtype-stype
c
c  Stress source.
c
          else

              call trans_stod (
     i                         nf_dim,
     i                         df,nf,
     i                         alfa,beta,rho,
     i                         rs,r,
     o                         spect)

              iexpo=rtype

          endif
c
c  Calculate components of unit vector pointing from source to
c  receiver.
c
          erx=(xr-xs)/r
          ery=(yr-ys)/r
          erz=(zr-zs)/r
c
c  Retrieve receiver orientation vector components.
c
          bx=receivers(ir,5)
          by=receivers(ir,6)
          bz=receivers(ir,7)
c
c  Calculate inner-product of vectors defining source-to-reciever
c  orientation and receiver sensitivity axis.
c
          dotpro=erx*bx+ery*by+erz*bz
c
c  Multiply by spectrum of source waveform, apply differentiation
c  factor, scale by source and receiver amplitude factors, scale
c  to component of motion recorded by receiver.  Note that DC
c  frequency is not included in multiplication.  Finally, divide
c  by a factor appropriate for a pressure source.
c
          factr=samp*ramp*dotpro
          do 50 if=2,nf
          f=(if-1)*df
          arg=eye*pi2*f
          spect(if)=spect(if)*spect_s(if)*(arg**iexpo)*factr
   50     spect(if)=spect(if)/divisor
c
c  DC frequency is treated as a special case.  Consider
c  displacement/velocity/acceleration sources first.  Logic is
c  valid for both elastic (beta exceeds zero) and acoustic 
c  (beta equals zero) media.
c
          if (stype.lt.4.0) then

              if (iexpo.gt.0) then
                  spect(1)=zero
              endif

              if (iexpo.eq.0) then
                  spect(1)=spect(1)*spect_s(1)*factr
              endif

              if (iexpo.lt.0) then
                  if (spect_s(1).eq.zero) then
                      spect(1)=zero
                  else
                      f=0.01*df
                      aprox=0.99*spect_s(1)+0.01*spect_s(2)
                      arg=eye*pi2*f
                      spect(1)=dtod(rs,r,alfa,f)
     &                        *aprox*(arg**iexpo)*factr
                  endif
              endif
c
c  Consider stress sources next.   Elastic (beta exceeds zero)
c  and acoustic (beta equals zero) media are treated with
c  separate logic.  Note that, for stress sources, quantity
c  "iexpo" is never negative.
c
          else

              if (beta.gt.0.0) then

                  if (iexpo.gt.0) then
                      spect(1)=zero
                  endif

                  if (iexpo.eq.0) then
                      spect(1)=spect(1)*spect_s(1)*factr
                  endif
 
              else

                  if (iexpo.eq.2) then
                      spect(1)=stoa_acoustic_dc(rs,r,alfa,rho)
     &                        *spect_s(1)*factr/divisor
                  endif

                  if (iexpo.lt.2) then
                      f=0.01*df
                      aprox=0.99*spect_s(1)+0.01*spect_s(2)
                      if (iexpo.eq.0) arg=one
                      if (iexpo.eq.1) arg=eye*pi2*f
                      spect(1)=stod_acoustic(rs,r,alfa,rho,f)
     &                        *aprox*arg*factr/divisor
                  endif

              endif

          endif

      endif
c
c  Pressure receiver next.
c
      if (rtype.eq.4.0) then
c
c  Displacement/velocity/acceleration source.
c
          if (stype.lt.4.0) then
 
              call trans_dvatop (
     i                           nf_dim,
     i                           df,nf,
     i                           alfa,beta,rho,
     i                           stype,rs,r,
     o                           spect)
c
c  Stress source.
c
          else

              call trans_stop (
     i                         nf_dim,
     i                         df,nf,
     i                         alfa,beta,
     i                         rs,r,
     o                         spect)

          endif
c
c  Multiply by spectrum of source waveform, scale by source
c  and receiver amplitude factors.  Note that DC frequency is
c  included in multiplication.
c
          factr=samp*ramp
          do 55 if=1,nf
          f=(if-1)*df
   55     spect(if)=spect(if)*spect_s(if)*factr

      endif
c
c  Linearly ramp spectrum to zero at Nyquist frequency.  A 5-point
c  ramp is chosen here; this is easily changed.
c
      nramp=5
      do 60 if=nf-nramp,nf
      ramper=float(nf-if)/float(nramp+1)
   60 spect(if)=spect(if)*ramper
c
c  Extend spectrum to negative frequencies using Hermitian symmetry.
c
      do 70 if=1,nf-2
   70 spect(nf+if)=conjg(spect(nf-if))
c
c  Load complex-valued spectrum into a real-valued array for
c  subsequent inverse FFT.
c
      do 80 if=1,nsamps
      kk=2*if-1
      data(kk)  = real(spect(if))
   80 data(kk+1)=aimag(spect(if))
c
c  Inverse FFT real-valued array containing the Fourier spectrum to 
c  obtain the time-domain trace.  Parameter isign is set equal to +1,
c  rather than -1, because the sign convention utilized within FFT
c  subroutine FOUR1 is opposite to that assumed in program EXPLOD.
c
      isign=1
      call four1 (
     i            nf_dim,
     i            nsamps,isign,
     b            data)
c
c  Select spatial coordinate for referencing trace output.
c
      if (iplot.eq.1) coord=xr
      if (iplot.eq.2) coord=yr
      if (iplot.eq.3) coord=zr
      if (iplot.eq.4) coord=ir
c
c  Write trace to file #3 in ASCII table format; output only the 
c  samples within the trace time window [tmin, tmin+tlen].  Note
c  mulitiplication by frequency sampling interval df to put trace 
c  into proper physical dimension.
c
      write (3,9100)
 9100 format ('>')

      if (iplot.gt.0) then
      
          do 90 it=1,nsamps_io
          t=tmin+(it-1)*dt
          kk=2*it-1
ccc   90     write (3,*) dscale*coord,tscale*t,ascale*df*data(kk)
   90     write (3,*) tscale*t,dscale*coord,ascale*df*data(kk)

      else

          do 91 it=1,nsamps_io
          t=tmin+(it-1)*dt
          kk=2*it-1
   91     write (3,*) tscale*t,ascale*df*data(kk)

      endif
c
c  Continue to next trace.
c
  100 continue

      stop
      end


cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc
cc  Subroutine TRANS_DTOD calculates a frequency-domain transfer
cc  function that converts source radial displacement at radius rs
cc  to radial particle displacement at distance r.  Subroutine is valid
cc  for either elastic (beta postive) or acoustic (beta zero) media. 
cc
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
      subroutine trans_dtod (
     i                       nf_dim,
     i                       df,nf,
     i                       alfa,
     i                       rs,r,
     o                       spect)
c
c  Dimension arrays and declare complex variables.
c
      complex*8 spect(nf_dim)
      complex*8 eye,pole1,zero1
c
c  Calculate constants.
c
      pi=3.141592653589794
      pi2=2.0*pi
      eye=cmplx(0.0,1.0)

      amp=(rs/r)
      tau=(r-rs)/alfa

      pole1=(eye*alfa)/(pi2*rs)
      zero1=(eye*alfa)/(pi2*r)
c
c  Calculate frequency-domain transfer function (source radial
c  displacement to radial particle displacement).
c
      do 10 if=1,nf
      f=(if-1)*df
   10 spect(if)=amp*((f-zero1)/(f-pole1))*cexp(-eye*pi2*f*tau)
 
      return
      end


cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc
cc  Subroutine TRANS_STOD calculates a frequency-domain transfer
cc  function that converts source radial stress at radius rs to radial 
cc  particle displacement at distance r.  Subroutine is valid for
cc  either elastic (beta postive) or acoustic (beta zero) media.
cc
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
      subroutine trans_stod (
     i                       nf_dim,
     i                       df,nf,
     i                       alfa,beta,rho,
     i                       rs,r,
     o                       spect)
c
c  Dimension arrays and declare complex variables.
c
      complex*8 spect(nf_dim)
      complex*8 eye,pole1,pole2,zero1,amp
c
c  Calculate constants.
c
      pi=3.141592653589794
      pi2=2.0*pi
      eye=cmplx(0.0,1.0)

      amp=(rs/r)/(eye*pi2*rho*alfa)
      tau=(r-rs)/alfa

      gamma=beta/alfa
      pole1=(beta/(pi*rs))*cmplx(sqrt(1.0-gamma**2),gamma)
      pole2=-conjg(pole1)
      zero1=(eye*alfa)/(pi2*r)
c
c  Calculate frequency-domain transfer function (source radial stress
c  to radial particle displacement) for elastic medium (beta positive).
c
      if (beta.gt.0.0) then

          do 10 if=1,nf
          f=(if-1)*df
   10     spect(if)=amp*((f-zero1)/((f-pole1)*(f-pole2)))
     &             *cexp(-eye*pi2*f*tau)

      endif
c
c  Calculate frequency-domain transfer function (source radial stress
c  to radial particle displacement) for acoustic medium (beta zero).
c
      if (beta.eq.0.0) then

          do 20 if=2,nf
          f=(if-1)*df
   20     spect(if)=amp*((f-zero1)/(f*f))*cexp(-eye*pi2*f*tau)
c
c  DC frequency is treated as a special case.  Transfer function 
c  formula is evaluated at a small positive frequency.
c
          f=0.01*df
          spect(1)=amp*((f-zero1)/(f*f))*cexp(-eye*pi2*f*tau)

      endif
 
      return
      end


cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc
cc  Subroutine TRANS_DVATOP calculates a frequency-domain transfer
cc  function that converts source radial displacement/velocity/
cc  acceleration at radius rs to pressure at distance r.  Subroutine
cc  is valid for either elastic (beta nonzero) or acoustic (beta
cc  zero) media.
cc
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
      subroutine trans_dvatop (
     i                         nf_dim,
     i                         df,nf,
     i                         alfa,beta,rho,
     i                         stype,rs,r,
     o                         spect)
c
c  Dimension arrays and declare complex variables.
c
      complex*8 spect(nf_dim)
      complex*8 eye,arg,pole1
c
c  Calculate constants.
c
      pi=3.141592653589794
      pi2=2.0*pi
      eye=cmplx(0.0,1.0)

      gamma=beta/alfa
      amp=rho*alfa*(1.0-(4.0/3.0)*gamma**2)*(rs/r)
      tau=(r-rs)/alfa

      pole1=(eye*alfa)/(pi2*rs)
c
c  Calculate frequency-domain transfer function (source radial
c  displacement to pressure).
c
      if (stype.eq.0.0) then

          do 10 if=1,nf
          f=(if-1)*df
          arg=eye*pi2*f
   10     spect(if)=amp*(f/(f-pole1))*cexp(-arg*tau)*arg

      endif
c
c  Calculate frequency-domain transfer function (source radial
c  velocity to pressure).
c
      if (stype.eq.1.0) then

          do 20 if=1,nf
          f=(if-1)*df
          arg=eye*pi2*f
   20     spect(if)=amp*(f/(f-pole1))*cexp(-arg*tau)

      endif
c
c  Calculate frequency-domain transfer function (source radial
c  acceleration to pressure).
c
      if (stype.eq.2.0) then

          do 30 if=1,nf
          f=(if-1)*df
          arg=eye*pi2*f
   30     spect(if)=(amp/((eye*pi2)*(f-pole1)))*cexp(-arg*tau)
  
      endif
 
      return
      end


cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc
cc  Subroutine TRANS_STOP calculates a frequency-domain transfer 
cc  function that converts source radial stress at radius rs to 
cc  pressure at distance r.  Subroutine is valid for either elastic
cc  (beta postive) or acoustic (beta zero) media.
cc
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
      subroutine trans_stop (
     i                       nf_dim,
     i                       df,nf,
     i                       alfa,beta,
     i                       rs,r,
     o                       spect)
c
c  Dimension arrays and declare complex variables.
c
      complex*8 spect(nf_dim)
      complex*8 eye,pole1,pole2
c
c  Calculate constants.
c
      pi=3.141592653589794
      pi2=2.0*pi
      eye=cmplx(0.0,1.0)

      gamma=beta/alfa
      amp=(1.0-(4.0/3.0)*gamma**2)*(rs/r)
      tau=(r-rs)/alfa

      pole1=(beta/(pi*rs))*cmplx(sqrt(1.0-gamma**2),gamma)
      pole2=-conjg(pole1)
c
c  Calculate frequency-domain transfer function (source radial stress
c  to receiver pressure) for elastic medium (beta postive).
c
      if (beta.gt.0.0) then

          do 10 if=1,nf
          f=(if-1)*df
   10     spect(if)=amp*(f/(f-pole1))*(f/(f-pole2))
     &             *cexp(-eye*pi2*f*tau)

      endif
c
c  Calculate frequency-domain transfer function (source pressure
c  to receiver pressure) for acoustic medium (beta equals zero). 
c
      if (beta.eq.0.0) then
 
          do 20 if=1,nf
          f=(if-1)*df
   20     spect(if)=amp*cexp(-eye*pi2*f*tau)

      endif
 
      return
      end


cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc
cc  Function DTOD calculates a transfer function for source radial
cc  displacement to receiver radial displacement, for a given input
cc  frequency f.
cc
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
      function dtod(rs,r,alfa,f)
 
      complex*8 eye,pole1,zero1,dtod
 
      pi=3.141592653589794
      pi2=2.0*pi
      eye=cmplx(0.0,1.0)

      amp=(rs/r)
      tau=(r-rs)/alfa

      pole1=(eye*alfa)/(pi2*rs)
      zero1=(eye*alfa)/(pi2*r )

      dtod=amp*((f-zero1)/(f-pole1))*cexp(-eye*pi2*f*tau)
 
      return
      end


cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc
cc  Function STOD_ACOUSTIC calculates a transfer function for source
cc  radial stress to receiver radial displacement, for a given input 
cc  frequency f, and for an acoustic (beta equals zero) medium.
cc  Do not use this subroutine for frequency f = 0!
cc
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
      function stod_acoustic(rs,r,alfa,rho,f)

      complex*8 eye,zero1,stod_acoustic
 
      pi=3.141592653589794
      pi2=2.0*pi
      eye=cmplx(0.0,1.0)

      amp=(rs/r)/(rho*alfa)
      tau=(r-rs)/alfa

      zero1=(eye*alfa)/(pi2*r)

      stod_acoustic=amp*((f-zero1)/(f*f))
     &             *cexp(-eye*pi2*f*tau)/(pi2*eye)
 
      return
      end


cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc
cc  Function STOA_ACOUSTIC_DC calculates a transfer function for source
cc  radial stress to receiver radial acceleration, for DC frequency
cc  (f = 0), and for an acoustic (beta equals zero) medium.
cc
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
      function stoa_acoustic_dc(rs,r,alfa,rho)

      complex*8 eye,zero1,stoa_acoustic_dc
 
      pi=3.141592653589794
      pi2=2.0*pi
      eye=cmplx(0.0,1.0)

      amp=(rs/r)/(rho*alfa)

      zero1=(eye*alfa)/(pi2*r)

      stoa_acoustic_dc=-amp*zero1*eye*pi2
 
      return
      end


cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc
cc  Subroutine RUN_PARAM reads run parameters from file #1 and performs
cc  elementary validity checks.
cc
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
      subroutine run_param (
     i                      nr_dim,
     o                      alfa,beta,rho,
     o                      tmin,dt,tlen,
     o                      xs,ys,zs,rs,samp,stype,
     o                      receivers,nr,
     o                      tscale,dscale,ascale,iplot)
c
c  Dimension array.
c
      real*4 receivers(nr_dim,8)
c
c  Define constant.
c
      pi=3.141592653589794
c
c  Read earth model parameters.
c
      read (1,*) alfa,beta,rho
c
c  Check for stupid input mistakes in P-wave speed and mass density.
c
      if (alfa.le.0.0) then
          write (6,9001)
 9001     format (15x,'Invalid P-wave speed!')
          stop
      endif
 
      if (rho.le.0.0) then
          write (6,9002)
 9002     format (15x,'Invalid mass density!')
          stop
      endif
c
c  Check validity of shear wave speed.
c
      aa=sqrt(2.0)/2.0
      bb=sqrt(3.0)/2.0
      gamma=beta/alfa
 
      if ((gamma.lt.0.0).or.(gamma.gt.bb)) then
          write (6,9003)
 9003     format (15x,'Nonphysical shear wave speed!')
          stop
      endif
 
      if ((gamma.gt.aa).and.(gamma.le.bb)) then
          write (6,9004)
 9004     format (15x,'Warning: negative Poisson ratio!')
      endif
c
c  Read grid parameters for trace output.
c
      read (1,*) tmin,dt,tlen
c
c  Check parameter validity.
c
      if (dt.le.0) then
          write (6,9005)
 9005     format (15x,'Invalid time sample interval!')
          stop
      endif
 
      if (tlen.le.0) then
          write (6,9006)
 9006     format (15x,'Invalid trace length!')
          stop
      endif
c
c  Read coordinates of center of source sphere.
c
      read (1,*) xs,ys,zs
c
c  Read radius of source sphere.
c
      read (1,*) rs
c
c  Check validity.
c
      if (rs.le.0.0) then
          write (6,9007)
 9007     format (15x,'Invalid source radius!')
          stop
      endif
c
c  Read source amplitude scalar.
c
      read (1,*) samp
c
c  Read source wavelet type.
c
      read (1,*) stype
c
c  Check validity.
c
      if ((stype.ne.0.0).and.(stype.ne.1.0).and.
     &    (stype.ne.2.0).and.(stype.ne.4.0).and.
     &    (stype.ne.5.0)) then
          write (6,9008) 
 9008     format (15x,'Invalid source type!')
          stop
      endif
c
c  Read number of receivers.
c
      read (1,*) nr
c
c  Check validity.
c
      if (nr.le.0) then
          write (6,9009)
 9009     format (15x,'Invalid number of receivers!')
          stop
      endif
c
c  Read receiver parameters.
c
      do 10 ir=1,nr

      read (1,*) rtype,xr,yr,zr,ramp,theta,phi
c
c  Check validity of receiver type.  This program only allows
c  displacement (rtype=0), velocity (rtype=1), acceleration
c  (rtype=2), or pressure (rtype=4) receivers.
c
      if ((rtype.ne.0.0).and.(rtype.ne.1.0).and.
     &    (rtype.ne.2.0).and.(rtype.ne.4.0)) then
          write (6,9010) ir
 9010     format (15x,'Invalid receiver type!',6x,
     &                'Receiver number ',i3)
          stop
      endif
c
c  Check validity of receiver position.  Distance from center of
c  source sphere to receiver must equal or exceed radius of source
c  sphere.
c
      r=sqrt((xr-xs)**2+(yr-ys)**2+(zr-zs)**2)
      if (r.lt.rs) then
          write (6,9011) ir
 9011     format (15x,'Invalid receiver location!',6x,
     &                'Receiver number ',i3)
          stop
      endif
c
c  Convert orientation angles to radians and calculate
c  components of receiver unit orientation vector.
c
      if ((theta.lt.0.0).or.(theta.gt.180.0)) then
          write (6,9012) ir
 9012     format (15x,'Invalid polar angle!',6x,
     &                'Receiver number ',i3)
          stop
      endif

      if ((phi.lt.0.0).or.(phi.gt.360.0)) then
          write (6,9013) ir
 9013     format (15x,'Invalid azimuth angle!',6x,
     &                'Receiver number ',i3)
          stop
      endif

      theta=pi*(theta/180.0)
      phi  =pi*(phi/180.0)

      bx=sin(theta)*cos(phi)
      by=sin(theta)*sin(phi)
      bz=cos(theta)

      if (rtype.eq.4.0) then
          bx=0.0
          by=0.0
          bz=0.0
      endif
c
c  Store receiver parameters.
c
      receivers(ir,1)=rtype
      receivers(ir,2)=xr
      receivers(ir,3)=yr
      receivers(ir,4)=zr
      receivers(ir,5)=bx
      receivers(ir,6)=by
      receivers(ir,7)=bz
      receivers(ir,8)=ramp

   10 continue
c
c  Read plot parameters for trace output.
c
      read (1,*) dscale,tscale,ascale,iplot
c
c  Check plot flag validity.
c
      if ((iplot.ne.1).and.(iplot.ne.2).and.
     &    (iplot.ne.3).and.(iplot.ne.4).and.
     &    (iplot.ne.0)) then
          write (6,9015)
 9015     format (15x,'Invalid trace plot option flag!')
          stop
      endif
c
c  If trace plots are referenced by receiver number, then
c  set distance scalar equal to 1.0.
c
      if (iplot.eq.4) dscale=1.0
 
      return
      end


cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc
cc  Subroutine FOUR1 implements an FFT of the input array "data".
cc  The code is from "Numerical Recipies, The Art of Scientific
cc  Computing", by Press et al., pages 501-502 (1992).  Length "nn" of
cc  the input array MUST be a power of 2!
cc
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
      subroutine four1 (
     i                  nf_dim,
     i                  nn,isign,
     b                  data)
 
      real*4 data(nf_dim)
      real*8 wr,wi,wpr,wpi,wtemp,theta
 
      n=2*nn
      j=1
 
      do 11 i=1,n,2
 
          if (j.gt.i) then
 
              tempr=data(j)
              tempi=data(j+1)
              data(j)=data(i)
              data(j+1)=data(i+1)
              data(i)=tempr
              data(i+1)=tempi
 
          endif
 
          m=n/2
 
    1     if ((m.ge.2).and.(j.gt.m)) then
 
              j=j-m
              m=m/2
              go to 1
 
          endif
 
          j=j+m
 
   11 continue
 
      mmax=2
 
    2 if (n.gt.mmax) then
 
          istep=2*mmax
          theta=6.28318530717959d0/(isign*mmax)
          wpr=-2.d0*dsin(0.5d0*theta)**2
          wpi=dsin(theta)
          wr=1.0d0
          wi=0.0d0
 
          do 13 m=1,mmax,2
 
              do 12 i=m,n,istep
 
                  j=i+mmax
                  tempr=sngl(wr)*data(j)-sngl(wi)*data(j+1)
                  tempi=sngl(wr)*data(j+1)+sngl(wi)*data(j)
                  data(j)=data(i)-tempr
                  data(j+1)=data(i+1)-tempi
                  data(i)=data(i)+tempr
                  data(i+1)=data(i+1)+tempi
 
   12         continue
 
              wtemp=wr
              wr=wr*wpr-wi*wpi+wr
              wi=wi*wpr+wtemp*wpi+wi
 
   13     continue
 
          mmax=istep
          go to 2
 
      endif
 
      return
      end
